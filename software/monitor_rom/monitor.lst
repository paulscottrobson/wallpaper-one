 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 1 - 1/17/2016 15:58:10


       1/       0 :                     ; ******************************************************************************************************************
       2/       0 :                     ; ******************************************************************************************************************
       3/       0 :                     ;
       4/       0 :                     ;												Machine Language Monitor
       5/       0 :                     ;
       6/       0 :                     ; ******************************************************************************************************************
       7/       0 :                     ; ******************************************************************************************************************
       8/       0 :                     
       9/       0 :                     		cpu	sc/mp
      10/       0 :                     
      11/       0 : =0xC00              labels 		= 0xC00												; labels, 1 byte each
      12/       0 : =0x18               labelCount 	= 24 												; number of labels.
      13/       0 :                     
      14/       0 : =0xC18              varBase 	= labels+labelCount 								; variables after labels start here.
      15/       0 :                     
      16/       0 : =0xC18              cursor 		= varBase 											; cursor position ($00-$7F)
      17/       0 : =0xC19              current 	= varBase+1 										; current address (lo,hi)
      18/       0 : =0xC1B              isInit      = varBase+3 										; if already initialised, this is $A7.
      19/       0 : =0xC1C              parPosn		= varBase+4 										; current param offset in buffer (low addr)
      20/       0 : =0xC1D              modifier  	= varBase+5 										; instruction modifier (@,Pn) when assembling.
      21/       0 : =0xC1E              kbdBuffer 	= varBase+6 										; 16 character keyboard buffer
      22/       0 : =0x10               kbdBufferLn = 16 										
      23/       0 :                     
      24/       0 : =0xC2E              codeStart 	= kbdBuffer+kbdBufferLn								; user code starts here after the keyboard buffer.
      25/       0 :                     														
      26/       0 : =0x4                tapeDelay 	= 4 												; DLY parameter for 1 tape bit width.
      27/       0 :                     																; (smaller = faster tape I/O - see file end.)
      28/       0 :                     
      29/       0 :                     		org 	0x0000
      30/       0 : 08                  		nop 													; mandatory pre-increment NOP
      31/       1 :                     
      32/       1 :                     ; ******************************************************************************************************************
      33/       1 :                     ;
      34/       1 :                     ;								Screen Handler (scrolling type) now in ROM Monitor
      35/       1 :                     ;
      36/       1 :                     ; ******************************************************************************************************************
      37/       1 :                     	
      38/       1 :                     		include macros.asm
(1)    1/       1 :                     ; ****************************************************************************************************************
(1)    2/       1 :                     ; ****************************************************************************************************************
(1)    3/       1 :                     ;														Macros
(1)    4/       1 :                     ; ****************************************************************************************************************
(1)    5/       1 :                     ; ****************************************************************************************************************
(1)    6/       1 :                     
(1)    7/       1 :                     lpi	macro	ptr,addr											; load pointer register with constant
(1)    8/       1 :                     	ldi 	(addr) / 256
(1)    9/       1 :                     	xpah 	ptr
(1)   10/       1 :                     	ldi 	(addr) & 255
(1)   11/       1 :                     	xpal 	ptr
(1)   12/       1 :                     	endm
(1)   13/       1 :                     
(1)   14/       1 :                     pushp macro ptr 												; push pointer register on stack
(1)   15/       1 :                     	xpah 	ptr
(1)   16/       1 :                     	st 		@-1(p2)
(1)   17/       1 :                     	xpal 	ptr
(1)   18/       1 :                     	st 		@-1(p2)
(1)   19/       1 :                     	endm
(1)   20/       1 :                     
(1)   21/       1 :                     pullp macro ptr 												; pull pointer register off stack
(1)   22/       1 :                     	ld 		@1(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm(macros.asm) - page 2 - 1/17/2016 15:58:10


(1)   23/       1 :                     	xpal 	ptr
(1)   24/       1 :                     	ld 		@1(p2)
(1)   25/       1 :                     	xpah 	ptr
(1)   26/       1 :                     	endm
(1)   27/       1 :                     
(1)   28/       1 :                     pushe macro 													; push E on stack
(1)   29/       1 :                     	lde
(1)   30/       1 :                     	st 		@-1(p2)
(1)   31/       1 :                     	endm
(1)   32/       1 :                     
(1)   33/       1 :                     pulle macro 													; pull E off stack
(1)   34/       1 :                     	ld 		@1(p2)
(1)   35/       1 :                     	xae
(1)   36/       1 :                     	endm
(1)   37/       1 :                     
(1)   38/       1 :                     pusha macro 													; push A on stack
(1)   39/       1 :                     	st 		@-1(p2)
(1)   40/       1 :                     	endm
(1)   41/       1 :                     
(1)   42/       1 :                     pulla macro
(1)   43/       1 :                     	ld 		@1(p2)
(1)   44/       1 :                     	endm
(1)   45/       1 :                     
      39/       1 :                     		include screen.asm 
(1)    1/       1 :                     ; ****************************************************************************************************************
(1)    2/       1 :                     ; ****************************************************************************************************************
(1)    3/       1 :                     ;
(1)    4/       1 :                     ;											Screen I/O, VTL-2 ROM
(1)    5/       1 :                     ;											=====================
(1)    6/       1 :                     ;
(1)    7/       1 :                     ;	Provides Character and String Input/Output functionality.
(1)    8/       1 :                     ;
(1)    9/       1 :                     ; ****************************************************************************************************************
(1)   10/       1 :                     ; ****************************************************************************************************************
(1)   11/       1 :                     
(1)   12/       1 : =0xC00              ScreenMirror = 0xC00 										; Screen Mirror ($C00-$C7F)
(1)   13/       1 : =0xC80              ScreenCursor = 0xC80 										; Current Cursor position ($C80)
(1)   14/       1 :                     
(1)   15/       1 : 90 06               	jmp 	__Screen_Over1 									; avoid the vector table
(1)   16/       3 : 90 2F               	jmp 	__Print2 										; 0003 Print (Character or String)
(1)   17/       5 : 90 09               	jmp 	GetChar 										; 0005 Get Character
(1)   18/       7 : 90 2D               	jmp 	GetString										; 0007 Get String
(1)   19/       9 :                     
(1)   20/       9 :                     __Screen_Over1:
(1)   21/       9 : (MACRO)             	lpi 	p3,Screen__End-1 								; jump over all the screen code.
(1)   21/       9 : C4 01                       ldi     (SCREEN__END-1) / 256
(1)   21/       B : 37                          xpah    P3
(1)   21/       C : C4 5D                       ldi     (SCREEN__END-1) & 255
(1)   21/       E : 33                          xpal    P3
(1)   22/       F : 3F                  	xppc 	p3
(1)   23/      10 :                     
(1)   24/      10 :                     ; ****************************************************************************************************************
(1)   25/      10 :                     ; ****************************************************************************************************************
(1)   26/      10 :                     ;
(1)   27/      10 :                     ;		Input a single character into A. Case is converted to Upper. All registers preserved except A
(1)   28/      10 :                     ;
(1)   29/      10 :                     ; ****************************************************************************************************************
(1)   30/      10 :                     ; ****************************************************************************************************************
(1)   31/      10 :                     
(1)   32/      10 :                     GetChar:
 AS V1.42 Beta [Bld 102] - source file monitor.asm(screen.asm) - page 3 - 1/17/2016 15:58:10


(1)   33/      10 :                     	section 	GetChar
(1)   34/      10 : C4 08               	ldi 	0x8 												; set P1 to $8xx, and save P1.H
(1)   35/      12 : 35                  	xpah 	p1
(1)   36/      13 : CE FF               	st 		@-1(p2)
(1)   37/      15 :                     __GCWaitKey: 													; wait for key press
(1)   38/      15 : C1 00               	ld 		0(p1)
(1)   39/      17 : 94 FC               	jp 		__GCWaitKey
(1)   40/      19 : D4 7F               	ani	 	0x7F 												; throw away the upper bit.
(1)   41/      1B : CA FF               	st 		-1(p2) 												; save it below stack
(1)   42/      1D :                     __GCWaitRelease:
(1)   43/      1D : C1 00               	ld 		0(p1) 												; wait for release
(1)   44/      1F : D4 80               	ani 	0x80
(1)   45/      21 : 9C FA               	jnz 	__GCWaitRelease
(1)   46/      23 : C6 01               	ld 		@1(p2) 												; restore P1.H
(1)   47/      25 : 35                  	xpah 	p1
(1)   48/      26 : C2 FE               	ld 		-2(p2) 												; restore saved value
(1)   49/      28 : 02                  	ccl
(1)   50/      29 : F4 20               	adi 	0x20												; will make lower case -ve
(1)   51/      2B : 94 02               	jp 		__GCNotLower
(1)   52/      2D : FC 20               	cai 	0x20 												; capitalise
(1)   53/      2F :                     __GCNotLower:
(1)   54/      2F : F4 E0               	adi 	0xE0 												; fix up.
(1)   55/      31 : 3F                  	xppc 	p3 													; return
(1)   56/      32 : 90 DC               	jmp 	GetChar 											; make re-entrant
(1)   57/      34 :                     	endsection 	GetChar
(1)   58/      34 :                     
(1)   59/      34 :                     __Print2:
(1)   60/      34 : 90 68               	jmp 	Print
(1)   61/      36 :                     
(1)   62/      36 :                     ; ****************************************************************************************************************
(1)   63/      36 :                     ; ****************************************************************************************************************
(1)   64/      36 :                     ;
(1)   65/      36 :                     ;			Read an ASCIIZ string from keyboard into P1 of length A maximum (excludes NULL terminator)
(1)   66/      36 :                     ;
(1)   67/      36 :                     ; ****************************************************************************************************************
(1)   68/      36 :                     ; ****************************************************************************************************************
(1)   69/      36 :                     
(1)   70/      36 :                     GetString:
(1)   71/      36 :                     	section GetString
(1)   72/      36 : (MACRO)             	pusha 														; save A,P3,E
(1)   72/      36 : CE FF                       st              @-1(p2)
(1)   73/      38 : (MACRO)             	pushp 	p3
(1)   73/      38 : 37                          xpah    P3
(1)   73/      39 : CE FF                       st              @-1(p2)
(1)   73/      3B : 33                          xpal    P3
(1)   73/      3C : CE FF                       st              @-1(p2)
(1)   74/      3E : (MACRO)             	pushe 
(1)   74/      3E : 40                          lde
(1)   74/      3F : CE FF                       st              @-1(p2)
(1)   75/      41 : C4 00               	ldi 	0 													; set E (current position) to A.
(1)   76/      43 : 01                  	xae
(1)   77/      44 :                     __GSLoop:
(1)   78/      44 : (MACRO)             	lpi 	p3,Print-1 											; print the prompt (half coloured square)
(1)   78/      44 : C4 00                       ldi     (PRINT-1) / 256
(1)   78/      46 : 37                          xpah    P3
(1)   78/      47 : C4 9D                       ldi     (PRINT-1) & 255
(1)   78/      49 : 33                          xpal    P3
(1)   79/      4A : C4 9B               	ldi 	155
(1)   80/      4C : 3F                  	xppc 	p3
(1)   81/      4D : (MACRO)             	lpi 	p3,GetChar-1 										; get a character
 AS V1.42 Beta [Bld 102] - source file monitor.asm(screen.asm) - page 4 - 1/17/2016 15:58:10


(1)   81/      4D : C4 00                       ldi     (GETCHAR-1) / 256
(1)   81/      4F : 37                          xpah    P3
(1)   81/      50 : C4 0F                       ldi     (GETCHAR-1) & 255
(1)   81/      52 : 33                          xpal    P3
(1)   82/      53 : 3F                  	xppc 	p3
(1)   83/      54 : C9 80               	st 		-0x80(p1) 											; save it in the current position.
(1)   84/      56 : (MACRO)             	lpi 	p3,Print-1 											; erase the prompt with backspace.
(1)   84/      56 : C4 00                       ldi     (PRINT-1) / 256
(1)   84/      58 : 37                          xpah    P3
(1)   84/      59 : C4 9D                       ldi     (PRINT-1) & 255
(1)   84/      5B : 33                          xpal    P3
(1)   85/      5C : C4 08               	ldi 	8
(1)   86/      5E : 3F                  	xppc 	p3
(1)   87/      5F : C1 80               	ld 		-0x80(p1) 											; re-read character
(1)   88/      61 : D4 E0               	ani 	0xE0 												; check if control key.
(1)   89/      63 : 98 0F               	jz 		__GSControlKey 
(1)   90/      65 : 40                  	lde 														; get current position.
(1)   91/      66 : E2 03               	xor 	3(p2) 												; reached maximum length of buffer ?
(1)   92/      68 : 98 DA               	jz 		__GSLoop 											; if so, ignore the key and go round again.
(1)   93/      6A : C1 80               	ld 		-0x80(p1) 											; get character and print it
(1)   94/      6C : 3F                  	xppc 	p3
(1)   95/      6D : C4 01               	ldi 	1 													; increment E
(1)   96/      6F : 02                  	ccl
(1)   97/      70 : 70                  	ade
(1)   98/      71 : 01                  	xae
(1)   99/      72 : 90 D0               	jmp 	__GSLoop 											; and go round again.
(1)  100/      74 :                     ;
(1)  101/      74 :                     ;	Handle control keys (0x00-0x1F)
(1)  102/      74 :                     ;
(1)  103/      74 :                     __GSControlKey:
(1)  104/      74 : C1 80               	ld 		-0x80(p1) 											; get typed in key
(1)  105/      76 : E4 08               	xri 	8 													; check for backspace.
(1)  106/      78 : 98 17               	jz 		__GSBackspace 			
(1)  107/      7A : E4 05               	xri 	8!13 												; check for CR
(1)  108/      7C : 9C C6               	jnz 	__GSLoop 											; if not, ignore the key.
(1)  109/      7E :                     ;
(1)  110/      7E :                     ;	Carriage Return, ending input.
(1)  111/      7E :                     ;
(1)  112/      7E : C9 80               	st 		-0x80(p1) 											; replace the CR written with NULL terminator.
(1)  113/      80 : C4 0D               	ldi 	13 													; print CR
(1)  114/      82 : 3F                  	xppc 	p3
(1)  115/      83 : (MACRO)             	pulle 														; restore E,P3,A
(1)  115/      83 : C6 01                       ld              @1(p2)
(1)  115/      85 : 01                          xae
(1)  116/      86 : (MACRO)             	pullp	p3
(1)  116/      86 : C6 01                       ld              @1(p2)
(1)  116/      88 : 33                          xpal    P3
(1)  116/      89 : C6 01                       ld              @1(p2)
(1)  116/      8B : 37                          xpah    P3
(1)  117/      8C : (MACRO)             	pulla
(1)  117/      8C : C6 01                       ld              @1(p2)
(1)  118/      8E : 3F                  	xppc 	p3 													; return
(1)  119/      8F : 90 A5               	jmp 	GetString 											; make re-entrant (probably unneccessary !!)
(1)  120/      91 :                     ;
(1)  121/      91 :                     ;	Backspace entered
(1)  122/      91 :                     ;
(1)  123/      91 :                     __GSBackspace
(1)  124/      91 : 40                  	lde 														; if E = 0 we can't backspace any further.
(1)  125/      92 : 98 B0               	jz 		__GSLoop
(1)  126/      94 : C4 08               	ldi 	8 													; backspace on screen
 AS V1.42 Beta [Bld 102] - source file monitor.asm(screen.asm) - page 5 - 1/17/2016 15:58:10


(1)  127/      96 : 3F                  	xppc 	p3
(1)  128/      97 : C4 FF               	ldi 	0xFF 												; decrement E
(1)  129/      99 : 02                  	ccl
(1)  130/      9A : 70                  	ade
(1)  131/      9B : 01                  	xae
(1)  132/      9C : 90 A6               	jmp 	__GSLoop 											; and go round again.
(1)  133/      9E :                     
(1)  134/      9E :                     	endsection GetString
(1)  135/      9E :                     
(1)  136/      9E :                     ; ****************************************************************************************************************
(1)  137/      9E :                     ; ****************************************************************************************************************
(1)  138/      9E :                     ;
(1)  139/      9E :                     ;	Print routine. Prints either character in A, or ASCIIZ string at P1 (if A is zero). Preserves all registers
(1)  140/      9E :                     ;	except if printing string, P1 points to the character after the NULL terminator.
(1)  141/      9E :                     ;
(1)  142/      9E :                     ;	Scrolls automatically. Understands character codes 32-255, 8 (Backspace) 12 (Clear Screen) 13 (Carriage
(1)  143/      9E :                     ;	Return). Others are currently ignored (except 0, see above). Note L/C values (97....) display those characters
(1)  144/      9E :                     ;	in the ROM font *not* lower case :)
(1)  145/      9E :                     ;
(1)  146/      9E :                     ; ****************************************************************************************************************
(1)  147/      9E :                     ; ****************************************************************************************************************
(1)  148/      9E :                     
(1)  149/      9E :                     Print:
(1)  150/      9E :                     	section 	Print
(1)  151/      9E :                     
(1)  152/      9E : (MACRO)             	pusha														; push registers on stack
(1)  152/      9E : CE FF                       st              @-1(p2)
(1)  153/      A0 : (MACRO)             	pushp 	p1
(1)  153/      A0 : 35                          xpah    P1
(1)  153/      A1 : CE FF                       st              @-1(p2)
(1)  153/      A3 : 31                          xpal    P1
(1)  153/      A4 : CE FF                       st              @-1(p2)
(1)  154/      A6 : (MACRO)             	pushe
(1)  154/      A6 : 40                          lde
(1)  154/      A7 : CE FF                       st              @-1(p2)
(1)  155/      A9 :                     
(1)  156/      A9 : C2 03               	ld 		3(p2) 												; read character 
(1)  157/      AB : 9C 12               	jnz 	__PRPrintCharacterA 								; if non zero print it on its own.
(1)  158/      AD :                     
(1)  159/      AD :                     __PRPrintString:
(1)  160/      AD : C2 01               	ld 		1(p2) 												; restore original P1
(1)  161/      AF : 31                  	xpal 	p1
(1)  162/      B0 : C2 02               	ld 		2(p2)
(1)  163/      B2 : 35                  	xpah 	p1 													; read character at P1.
(1)  164/      B3 : C5 01               	ld 		@1(p1)
(1)  165/      B5 : 01                  	xae 														; save in E.
(1)  166/      B6 : 35                  	xpah 	p1 													; write P1 back.
(1)  167/      B7 : CA 02               	st 		2(p2)
(1)  168/      B9 : 31                  	xpal 	p1
(1)  169/      BA : CA 01               	st 		1(p2)
(1)  170/      BC : 40                  	lde 														; get character from E
(1)  171/      BD : 98 46               	jz 		__PRExitNoCheck 									; exit without loop check.
(1)  172/      BF :                     ;
(1)  173/      BF :                     ;	Print character in A now ; throughout it is stored in E.
(1)  174/      BF :                     ;
(1)  175/      BF :                     __PRPrintCharacterA:
(1)  176/      BF : 01                  	xae 														; save character in E.
(1)  177/      C0 :                     ;
(1)  178/      C0 :                     ;	Read cursor and set P1 to that address
(1)  179/      C0 :                     ;
 AS V1.42 Beta [Bld 102] - source file monitor.asm(screen.asm) - page 6 - 1/17/2016 15:58:10


(1)  180/      C0 : C4 0C               	ldi 	ScreenCursor/256 									; set P1 to point to screen cursor
(1)  181/      C2 : 35                  	xpah 	p1
(1)  182/      C3 : C4 80               	ldi 	ScreenCursor&255
(1)  183/      C5 : 31                  	xpal 	p1
(1)  184/      C6 : C1 00               	ld 		0(p1) 												; put cursor position in P1.L
(1)  185/      C8 : 31                  	xpal 	p1
(1)  186/      C9 :                     ;
(1)  187/      C9 :                     ;	Check for control
(1)  188/      C9 :                     ;
(1)  189/      C9 : 40                  	lde 														; look at character
(1)  190/      CA : D4 E0               	ani 	0xE0 												; is it code 0-31
(1)  191/      CC : 98 45               	jz 		__PRIsControlChar
(1)  192/      CE :                     ;
(1)  193/      CE :                     ;	Print non-control
(1)  194/      CE :                     ;
(1)  195/      CE : 40                  	lde 														; read character
(1)  196/      CF : 03                  	scl 														; CY/L clear if < 96
(1)  197/      D0 : FC 60               	cai 	96 
(1)  198/      D2 : 06                  	csa 	 	 												; skip if carry set
(1)  199/      D3 : E4 80               	xri 	0x80													
(1)  200/      D5 : 94 04               	jp 		__PRNotASCII
(1)  201/      D7 : 40                  	lde 														; if ASCII make 6 bit.
(1)  202/      D8 : D4 3F               	ani 	0x3F
(1)  203/      DA : 01                  	xae
(1)  204/      DB :                     __PRNotASCII:
(1)  205/      DB : 40                  	lde 														; get character.
(1)  206/      DC : C9 00               	st 		(p1) 												; save in shadow memory
(1)  207/      DE : 35                  	xpah 	p1 													; switch to VRAM, preserving A.
(1)  208/      DF : C4 00               	ldi 	0 													
(1)  209/      E1 : 35                  	xpah 	p1
(1)  210/      E2 : CD 01               	st 		@1(p1) 												; save in screen memory, advance write position.
(1)  211/      E4 :                     ;
(1)  212/      E4 :                     ;	Write cursor position back from P1.L
(1)  213/      E4 :                     ;
(1)  214/      E4 :                     __PRUpdateCursor:
(1)  215/      E4 : C4 0C               	ldi		ScreenCursor / 256 									; set P1 to point to screen cursor, restore position to P1
(1)  216/      E6 : 35                  	xpah 	p1
(1)  217/      E7 : C4 80               	ldi 	ScreenCursor & 255 
(1)  218/      E9 : 31                  	xpal 	p1 													; after this, adjusted cursor position is in AC.
(1)  219/      EA : C9 00               	st 		(p1) 												; write back in cursor position
(1)  220/      EC : 94 13               	jp 		__PRExit 											; if position is off the bottom then scroll.
(1)  221/      EE :                     ;
(1)  222/      EE :                     ;	Scroll display
(1)  223/      EE :                     ;
(1)  224/      EE : C4 0C               	ldi 	(ScreenMirror+16) / 256 							; point P1 to 2nd line.
(1)  225/      F0 : 35                  	xpah 	p1
(1)  226/      F1 : C4 10               	ldi 	(ScreenMirror+16) & 255
(1)  227/      F3 :                     __PRScrollLoop:
(1)  228/      F3 : 31                  	xpal 	p1
(1)  229/      F4 : C1 00               	ld 		0(p1) 												; copy char to previous line
(1)  230/      F6 : C9 F0               	st 		-16(p1)
(1)  231/      F8 : C5 01               	ld 		@1(p1) 												; bump pointer.
(1)  232/      FA : 31                  	xpal 	p1
(1)  233/      FB : 94 F6               	jp 		__PRScrollLoop
(1)  234/      FD : C4 70               	ldi 	128-16 												; clear from and move to last line
(1)  235/      FF : 90 3D               	jmp 	__PRClearFromMoveTo
(1)  236/     101 :                     ;
(1)  237/     101 :                     ;	Exit screen drawing routine.
(1)  238/     101 :                     ;
(1)  239/     101 :                     __PRExit:
 AS V1.42 Beta [Bld 102] - source file monitor.asm(screen.asm) - page 7 - 1/17/2016 15:58:10


(1)  240/     101 : C2 03               	ld 		3(p2) 												; if character was zero, loop
(1)  241/     103 : 98 A8               	jz 		__PRPrintString 									; back as printing string at P1.
(1)  242/     105 :                     __PRExitNoCheck:
(1)  243/     105 : (MACRO)             	pulle 														; restore registers
(1)  243/     105 : C6 01                       ld              @1(p2)
(1)  243/     107 : 01                          xae
(1)  244/     108 : (MACRO)             	pullp 	p1
(1)  244/     108 : C6 01                       ld              @1(p2)
(1)  244/     10A : 31                          xpal    P1
(1)  244/     10B : C6 01                       ld              @1(p2)
(1)  244/     10D : 35                          xpah    P1
(1)  245/     10E : (MACRO)             	pulla
(1)  245/     10E : C6 01                       ld              @1(p2)
(1)  246/     110 : 3F                  	xppc 	p3 													; return
(1)  247/     111 : 90 8B               	jmp 	Print 												; make re-entrant.
(1)  248/     113 :                     ;
(1)  249/     113 :                     ;	Check for supported control characters 8 (Backspace) 12 (Clear) 13 (Carriage Return)
(1)  250/     113 :                     ;
(1)  251/     113 :                     __PRIsControlChar:
(1)  252/     113 : 40                  	lde 														; restore character.
(1)  253/     114 : E4 0D               	xri 	13 													; carriage return ? (13)
(1)  254/     116 : 98 1B               	jz 		__PRIsReturn
(1)  255/     118 : E4 01               	xri 	13!12 												; form feed ? (12)
(1)  256/     11A : 98 20               	jz 		__PRClearScreen
(1)  257/     11C : E4 04               	xri 	12!8 												; backspace ? (8)
(1)  258/     11E : 9C E1               	jnz 	__PRExit 
(1)  259/     120 :                     ;
(1)  260/     120 :                     ;	Handle backspace (8)
(1)  261/     120 :                     ;
(1)  262/     120 : 31                  	xpal 	p1 													; check cursor position is zero
(1)  263/     121 : 98 DE               	jz 		__PRExit 											; if it is, cannot backspace so exit.
(1)  264/     123 : 31                  	xpal 	p1  												; put it back
(1)  265/     124 : C5 FF               	ld 		@-1(p1)												; move it back one
(1)  266/     126 : C4 20               	ldi 	' '	 												; erase in shadow
(1)  267/     128 : C9 00               	st 		(p1)
(1)  268/     12A : C4 00               	ldi 	0 													; point P1 to VRAM
(1)  269/     12C : 35                  	xpah 	p1
(1)  270/     12D : C4 20               	ldi 	' '													; erase in VRAM
(1)  271/     12F : C9 00               	st 		(p1)
(1)  272/     131 : 90 B1               	jmp 	__PRUpdateCursor 									; and exit
(1)  273/     133 :                     ;
(1)  274/     133 :                     ;	Handle carriage return (13)
(1)  275/     133 :                     ;
(1)  276/     133 :                     __PRIsReturn:
(1)  277/     133 : 31                  	xpal 	p1 													; cursor position in A
(1)  278/     134 : D4 F0               	ani 	0xF0 												; start of current line
(1)  279/     136 : 02                  	ccl 														; down one line
(1)  280/     137 : F4 10               	adi 	0x10 	
(1)  281/     139 : 31                  	xpal 	p1 													; put it back in P1.
(1)  282/     13A : 90 A8               	jmp 	__PRUpdateCursor
(1)  283/     13C :                     ;
(1)  284/     13C :                     ;	Handle clear screen (12)
(1)  285/     13C :                     ;
(1)  286/     13C :                     __PRClearScreen:
(1)  287/     13C : C4 00               	ldi 	0 													; clear shadow memory from here.
(1)  288/     13E :                     ;
(1)  289/     13E :                     ;	From position A, clear the memory in the shadow screen to the end, copy the shadow screen to VRAM
(1)  290/     13E :                     ;	then use position A as the new cursor position.
(1)  291/     13E :                     ;
(1)  292/     13E :                     __PRClearFromMoveTo:
 AS V1.42 Beta [Bld 102] - source file monitor.asm(screen.asm) - page 8 - 1/17/2016 15:58:10


(1)  293/     13E : CE FF               	st 		@-1(p2) 											; save this position, the cursor goes here.
(1)  294/     140 :                     __PRClearLoop:
(1)  295/     140 : 31                  	xpal 	p1 													; save position in P1.
(1)  296/     141 : C4 20               	ldi 	' '													; write space there.
(1)  297/     143 : CD 01               	st 		@1(p1)
(1)  298/     145 : 31                  	xpal 	p1
(1)  299/     146 : 94 F8               	jp 		__PRClearLoop 										; until reached shadow memory start.
(1)  300/     148 : C4 00               	ldi 	0 													; now copy shadow memory to screen memory.
(1)  301/     14A :                     __PRCopy:
(1)  302/     14A : 31                  	xpal 	p1 													; set up P1.L
(1)  303/     14B : C4 0C               	ldi 	ScreenMirror/256 									; point to shadow memory.
(1)  304/     14D : 35                  	xpah 	p1 													
(1)  305/     14E : C1 00               	ld 		(p1) 												; read shadow memory
(1)  306/     150 : 35                  	xpah 	p1 													; zero P1.H preserving A
(1)  307/     151 : C4 00               	ldi 	0
(1)  308/     153 : 35                  	xpah 	p1
(1)  309/     154 : CD 01               	st 		@1(p1) 												; save and increment p1
(1)  310/     156 : 31                  	xpal 	p1 
(1)  311/     157 : 94 F1               	jp 		__PRCopy 											; keep doing till all copied.
(1)  312/     159 : C6 01               	ld 		@1(p2) 												; read cursor position
(1)  313/     15B : 31                  	xpal 	p1 													; put in P1.L
(1)  314/     15C : 90 86               	jmp 	__PRUpdateCursor
(1)  315/     15E :                     
(1)  316/     15E :                     	endsection 	Print
(1)  317/     15E :                     
(1)  318/     15E :                     Screen__End:
(1)  319/     15E :                     
      40/     15E :                     
      41/     15E :                     ; ******************************************************************************************************************
      42/     15E :                     ;
      43/     15E :                     ;				Boot Up. First we check for a ROM @ $9000 and if it is 0x68 we boot there instead
      44/     15E :                     ;
      45/     15E :                     ; ******************************************************************************************************************
      46/     15E :                     
      47/     15E :                     BootMonitor:
      48/     15E : C4 90               		ldi 	0x90 											; point P1 to $9000 which is the first ROM.
      49/     160 : 35                  		xpah 	p1
      50/     161 : C1 00               		ld 		0(p1) 											; if that byte is $68, go straight there.
      51/     163 : E4 68               		xri 	0x68  											; we can boot into VTL-2 or whatever.
      52/     165 : 9C 01               		jnz 	__BootMonitor
      53/     167 : 3D                  		xppc 	p1 												; e.g. JMP $9001
      54/     168 :                     __BootMonitor:
      55/     168 :                     
      56/     168 :                     ; ******************************************************************************************************************
      57/     168 :                     ;
      58/     168 :                     ;									Find Top of Memory to initialise the stack.
      59/     168 :                     ;
      60/     168 :                     ;			(slightly tweaked to work round 4+12 emulator limitations - will work on real chip)
      61/     168 :                     ; ******************************************************************************************************************
      62/     168 :                     
      63/     168 : C4 0F               		ldi 	0x0F 											; point P2 to theoretical top of RAM on basic m/c
      64/     16A : 36                  		xpah 	p2 												; e.g. 0xFFF
      65/     16B : C4 FF               		ldi 	0xFF 											; ideally you'd make this 0x003F and remove the ld
      66/     16D : 32                  		xpal 	p2 												; but the emulators don't do 4+12 math. Only matters here.
      67/     16E : C6 40               		ld 		@64(p2) 										; fix the predecrement (wrap around not emulated)
      68/     170 :                     FindTopMemory:
      69/     170 : C4 A5               		ldi 	0xA5 											; try to write this to memory
      70/     172 : CE C0               		st 		@-64(p2) 										; predecrementing by 64.
      71/     174 : E2 00               		xor 	(p2) 											; did it write correctly.
      72/     176 : 9C F8               		jnz 	FindTopMemory 									; now P2 points to top of memory.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 9 - 1/17/2016 15:58:10


      73/     178 :                     
      74/     178 :                     ; ******************************************************************************************************************
      75/     178 :                     ;
      76/     178 :                     ;												Clear the screen
      77/     178 :                     ;
      78/     178 :                     ; ******************************************************************************************************************
      79/     178 :                     
      80/     178 :                     ClearScreen_Command:
      81/     178 : C4 00               		ldi 	0 												; set P1 to zero to access VRAM via write.
      82/     17A : 35                  		xpah 	p1
      83/     17B : C4 00               		ldi 	0
      84/     17D :                     ClearScreenLoop:
      85/     17D : 31                  		xpal 	p1												; clear screen
      86/     17E : C4 20               		ldi 	' '
      87/     180 : CD 01               		st 		@1(p1)
      88/     182 : 31                  		xpal 	p1
      89/     183 : 94 F8               		jp 		ClearScreenLoop
      90/     185 : C4 0C               		ldi 	Cursor/256 										; reset the cursor position to TOS
      91/     187 : 35                  		xpah 	p1
      92/     188 : C4 18               		ldi 	Cursor&255
      93/     18A : 31                  		xpal 	p1 
      94/     18B : C4 00               		ldi 	0 												; Note: could save 2 bytes here, P1.H is 0.
      95/     18D : C9 00               		st 		0(p1)											
      96/     18F :                     
      97/     18F :                     ; ****************************************************************************************************************
      98/     18F :                     ;
      99/     18F :                     ;												Check if initialised.
     100/     18F :                     ;
     101/     18F :                     ; ****************************************************************************************************************
     102/     18F :                     
     103/     18F : C1 03               		ld 		isInit-Cursor(p1) 								; have we initialised ?
     104/     191 : E4 A7               		xri 	0xA7 											; if so this byte should be $A7
     105/     193 : 98 4B               		jz 		CommandMainLoop
     106/     195 : C4 A7               		ldi 	0xA7 											; set the initialised byte
     107/     197 : C9 03               		st 		isInit-Cursor(p1)
     108/     199 :                     
     109/     199 : C4 0C               		ldi 	codeStart/256 									; set the initial work address
     110/     19B : C9 02               		st 		Current-Cursor+1(p1)
     111/     19D : C4 2E               		ldi 	codeStart&255
     112/     19F : C9 01               		st 		Current-Cursor(p1)
     113/     1A1 :                     																; print boot message - can lose this if required.
     114/     1A1 : C4 05               		ldi 	(PrintCharacter-1)/256 							; set P3 = print character.
     115/     1A3 : 37                  		xpah 	p3 
     116/     1A4 : C4 33               		ldi 	(PrintCharacter-1)&255
     117/     1A6 : 33                  		xpal 	p3
     118/     1A7 : C4 01               		ldi 	Message / 256 									; set P1 = boot message
     119/     1A9 : 35                  		xpah 	p1
     120/     1AA : C4 B4               		ldi 	Message & 255
     121/     1AC : 31                  		xpal 	p1
     122/     1AD :                     MessageLoop:
     123/     1AD : C5 01               		ld 		@1(p1) 											; read character
     124/     1AF : 98 22               		jz 		InitialBeep 									; end of message
     125/     1B1 : 3F                  		xppc 	p3 												; print it
     126/     1B2 : 90 F9               		jmp 	MessageLoop
     127/     1B4 :                     
     128/     1B4 :                     Message:
     129/     1B4 : 2A 2A 20 53 43 2F   		db 		"** SC/MP OS **",13 							; short boot message
                    4D 50 20 4F 53 20 
                    2A 2A 0D 
     130/     1C3 : 56 30 2E 39 34 20   		db 		"V0.94 PSR 2016",13
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 10 - 1/17/2016 15:58:10


                    50 53 52 20 32 30 
                    31 36 0D 
     131/     1D2 : 00                  		db 		0
     132/     1D3 :                     
     133/     1D3 :                     InitialBeep:
     134/     1D3 : C4 01               		ldi 	1 												; Beep on booting.
     135/     1D5 : 07                  		cas 													; play low tone
     136/     1D6 : 8F FF               		dly 	0xFF
     137/     1D8 : C4 05               		ldi 	5												; play high tone.
     138/     1DA : 07                  		cas
     139/     1DB : 8F FF               		dly 	0xFF
     140/     1DD : C4 00               		ldi 	0 												; sound off.
     141/     1DF : 07                  		cas
     142/     1E0 :                     
     143/     1E0 :                     ; ****************************************************************************************************************
     144/     1E0 :                     ;
     145/     1E0 :                     ;													Main Loop
     146/     1E0 :                     ;
     147/     1E0 :                     ; ****************************************************************************************************************
     148/     1E0 :                     
     149/     1E0 :                     CommandMainLoop:
     150/     1E0 : C4 05               		ldi 	(PrintAddressData-1)/256						; print Address only
     151/     1E2 : 37                  		xpah 	p3
     152/     1E3 : C4 A0               		ldi 	(PrintAddressData-1)&255
     153/     1E5 : 33                  		xpal 	p3
     154/     1E6 : C4 00               		ldi 	0 												; no data elements
     155/     1E8 : 3F                  		xppc 	p3
     156/     1E9 :                     
     157/     1E9 : C4 05               		ldi 	(PrintCharacter-1)/256 							; set P3 = print character.
     158/     1EB : 37                  		xpah 	p3
     159/     1EC : C4 33               		ldi 	(PrintCharacter-1)&255
     160/     1EE : 33                  		xpal 	p3
     161/     1EF : C4 5D               		ldi 	']'												; print the prompt.
     162/     1F1 : 3F                  		xppc 	p3
     163/     1F2 :                     
     164/     1F2 :                     ; ****************************************************************************************************************
     165/     1F2 :                     ;
     166/     1F2 :                     ;											Keyboard Line Input
     167/     1F2 :                     ;
     168/     1F2 :                     ; ****************************************************************************************************************
     169/     1F2 :                     
     170/     1F2 : C4 00               		ldi 	0 												; set E = character position.
     171/     1F4 : 01                  		xae 
     172/     1F5 :                     KeyboardLoop:
     173/     1F5 : C4 08               		ldi 	0x8 											; set P1 to point to keyboard latch
     174/     1F7 : 35                  		xpah 	p1
     175/     1F8 :                     _KBDWaitRelease:
     176/     1F8 : C1 00               		ld 		0(p1) 											; wait for strobe to clear
     177/     1FA : 94 02               		jp 		_KBDWaitKey
     178/     1FC : 90 FA               		jmp 	_KBDWaitRelease
     179/     1FE :                     _KBDWaitKey:
     180/     1FE : C1 00               		ld 		0(p1) 											; wait for strobe, i.e. new key
     181/     200 : 94 FC               		jp 		_KBDWaitKey
     182/     202 : D4 7F               		ani 	0x7F 											; throw away bit 7
     183/     204 : CA FF               		st 		-1(p2) 											; save key.
     184/     206 :                     
     185/     206 : C4 0C               		ldi 	kbdBuffer/256 									; set P1 = keyboard buffer
     186/     208 : 35                  		xpah 	p1
     187/     209 : C4 1E               		ldi 	kbdBuffer&255
     188/     20B : 31                  		xpal 	p1		
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 11 - 1/17/2016 15:58:10


     189/     20C :                     
     190/     20C : C2 FF               		ld 		-1(p2) 											; read key
     191/     20E : E4 08               		xri 	8 												; is it backspace
     192/     210 : 98 1E               		jz 		__KBDBackSpace
     193/     212 : E4 05               		xri 	8!13 											; is it CR, then exit
     194/     214 : 98 28               		jz 		__KBDExit
     195/     216 :                     
     196/     216 : 40                  		lde 													; have we a full buffer.
     197/     217 : E4 10               		xri 	kbdBufferLn 									; if so, ignore the key.
     198/     219 : 98 DA               		jz 		KeyboardLoop
     199/     21B :                     
     200/     21B : C2 FF               		ld 		-1(p2) 											; restore the key.
     201/     21D : 02                  		ccl
     202/     21E : F4 20               		adi 	0x20											; will make lower case -ve
     203/     220 : 94 02               		jp 		__KBDNotLower
     204/     222 : FC 20               		cai 	0x20 											; capitalise
     205/     224 :                     __KBDNotLower:
     206/     224 : F4 E0               		adi 	0xE0 											; fix up.
     207/     226 : C9 80               		st 		-0x80(p1) 										; save in the buffer using E as index.
     208/     228 : 3F                  		xppc 	p3 												; print the character
     209/     229 : 01                  		xae 													; increment E
     210/     22A : 02                  		ccl
     211/     22B : F4 01               		adi 	1
     212/     22D : 01                  		xae
     213/     22E : 90 C5               		jmp 	KeyboardLoop 									; and get the next key.
     214/     230 :                     
     215/     230 :                     __KBDBackSpace:
     216/     230 : 40                  		lde 													; get position
     217/     231 : 98 C2               		jz 		KeyboardLoop 									; can't go back if at beginning
     218/     233 : 03                  		scl 													; go back 1 from E
     219/     234 : FC 01               		cai 	1
     220/     236 : 01                  		xae 
     221/     237 : C4 08               		ldi 	8 												; print a backspace
     222/     239 : 3F                  		xppc 	p3
     223/     23A : 90 B9               		jmp 	KeyboardLoop 									; and go round again.
     224/     23C :                     
     225/     23C :                     __CmdMainLoop1:
     226/     23C : 90 A2               		jmp 	CommandMainLoop
     227/     23E :                     
     228/     23E :                     __KBDExit:
     229/     23E : C9 80               		st 		-0x80(p1) 										; add the ASCIIZ terminator.
     230/     240 : C4 0D               		ldi 	13												; print a new line.
     231/     242 : 3F                  		xppc 	p3
     232/     243 :                     
     233/     243 :                     ; ****************************************************************************************************************
     234/     243 :                     ;
     235/     243 :                     ;						Extract the 5 bit 3 letter (max command value). P1 points to buffer
     236/     243 :                     ;
     237/     243 :                     ; ****************************************************************************************************************
     238/     243 :                     
     239/     243 : C4 00               		ldi 	0
     240/     245 : 01                  		xae 													; E contains the LSB of the 5 bit shift
     241/     246 : 40                  		lde 	
     242/     247 : CA FF               		st 		-1(p2) 											; -1(P2) contains the MSB
     243/     249 : C9 FF               		st 		modifier-kbdBuffer(p1)							; clear the modifier.
     244/     24B :                     Extract5Bit:
     245/     24B : C1 00               		ld 		(p1) 											; look at character
     246/     24D : 02                  		ccl 													; add 128-65, will be +ve if < 64
     247/     24E : F4 3F               		adi 	128-65
     248/     250 : 94 1A               		jp 		__ExtractEnd
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 12 - 1/17/2016 15:58:10


     249/     252 : C4 05               		ldi 	5 												; shift current value left 5 times using -2(p2)
     250/     254 : CA FE               		st 		-2(p2)
     251/     256 :                     __Ex5Shift:
     252/     256 : 40                  		lde 													; shift E left into CY/L
     253/     257 : 02                  		ccl
     254/     258 : 70                  		ade 
     255/     259 : 01                  		xae
     256/     25A : C2 FF               		ld 		-1(p2) 											; shift CY/L into -1(p2) and carry/link
     257/     25C : F2 FF               		add 	-1(p2)
     258/     25E : CA FF               		st 		-1(p2)
     259/     260 : BA FE               		dld 	-2(p2) 											; done it 5 times ?
     260/     262 : 9C F2               		jnz 	__Ex5Shift
     261/     264 : C5 01               		ld 		@1(p1) 											; re-read character.
     262/     266 : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     263/     268 : 58                  		ore 													; OR into E
     264/     269 : 01                  		xae
     265/     26A : 90 DF               		jmp 	Extract5Bit 									; go and get the next one.
     266/     26C :                     
     267/     26C :                     __ExtractEnd:
     268/     26C : C4 1C               		ldi 	parPosn & 255 									; P1.L = Parameter Position, A = first non cmd char
     269/     26E : 31                  		xpal	p1
     270/     26F : C9 00               		st 		(p1) 											; write to parameter position.
     271/     271 :                     
     272/     271 :                     ; ****************************************************************************************************************
     273/     271 :                     ;
     274/     271 :                     ;						Find command in -1 (P2) (High) E (Low) in Command table
     275/     271 :                     ;	
     276/     271 :                     ; ****************************************************************************************************************
     277/     271 :                     
     278/     271 : C4 47               		ldi 	__commandList & 255 							; point P1 to the command list
     279/     273 : 31                  		xpal 	p1
     280/     274 : C4 07               		ldi 	__commandList / 256 		
     281/     276 : 35                  		xpah 	p1	
     282/     277 :                     __FindCommandLoop:
     283/     277 : C1 00               		ld 		0(p1) 											; reached the end of the table ?
     284/     279 : D9 01               		or 		1(p1)											; which is marked by word 0000
     285/     27B : 98 31               		jz 		__CommandError
     286/     27D : C5 03               		ld 		@3(p1) 											; read low byte, and point to next
     287/     27F : 60                  		xre
     288/     280 : 9C F5               		jnz 	__FindCommandLoop 								; if different to LSB loop back.
     289/     282 : C1 FE               		ld 		-2(p1) 											; read the high byte
     290/     284 : E2 FF               		xor 	-1(p2) 											; if different to the MSB loop back.
     291/     286 : 9C EF               		jnz 	__FindCommandLoop
     292/     288 :                     
     293/     288 :                     ; ****************************************************************************************************************
     294/     288 :                     ;
     295/     288 :                     ;				Found command, figure out if ASM or Command, if Command go to that routine
     296/     288 :                     ;
     297/     288 :                     ; ****************************************************************************************************************
     298/     288 :                     
     299/     288 : C4 D3               		ldi 	(GetParameter-1) & 255 							; point P3 to the get parameter code.
     300/     28A : 33                  		xpal 	p3
     301/     28B : C4 05               		ldi 	(GetParameter-1) / 256
     302/     28D : 37                  		xpah 	p3
     303/     28E :                     
     304/     28E : C1 FF               		ld 		-1(p1) 											; read the operation code.
     305/     290 : D4 F0               		ani 	0xF0 											; look at the m-s-nibble - commands are 0x20.
     306/     292 : E4 20               		xri 	0x20
     307/     294 : 9C 22               		jnz 	__Assembler
     308/     296 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 13 - 1/17/2016 15:58:10


     309/     296 : C1 FF               		ld 		-1(p1) 											; re-read it
     310/     298 : 02                  		ccl
     311/     299 : F1 FF               		add 	-1(p1) 											; double it
     312/     29B : D4 1F               		ani 	0x1F 											; lower 5 bits only.
     313/     29D : F4 EE               		adi 	__CommandTable & 255 							; make P1 point to the command table entry
     314/     29F : 31                  		xpal 	p1
     315/     2A0 : C4 07               		ldi 	__CommandTable / 256 					
     316/     2A2 : 35                  		xpah 	p1
     317/     2A3 : C1 00               		ld 		0(p1) 											; read low address
     318/     2A5 : 01                  		xae
     319/     2A6 : C1 01               		ld 		1(p1) 											; read high address
     320/     2A8 : 35                  		xpah 	p1 												; put in P1.H
     321/     2A9 : 40                  		lde 													; get low address
     322/     2AA : 31                  		xpal 	p1 												; put in P1.L
     323/     2AB : C5 FF               		ld 		@-1(p1) 										; fix up for the pre-increment
     324/     2AD : 3D                  		xppc 	p1 												; and go there.
     325/     2AE :                     
     326/     2AE :                     __CommandError: 												; unknown command.
     327/     2AE : C4 03               		ldi 	3 												; set the beeper on
     328/     2B0 : 07                  		cas
     329/     2B1 : 8F FF               		dly 	0xFF 											; short delay
     330/     2B3 : C4 00               		ldi 	0 												; set the beeper off
     331/     2B5 : 07                  		cas
     332/     2B6 : 90 84               		jmp 	__CmdMainLoop1
     333/     2B8 :                     
     334/     2B8 :                     ; ****************************************************************************************************************
     335/     2B8 :                     ;												In line Assembler
     336/     2B8 :                     ; ****************************************************************************************************************
     337/     2B8 :                     
     338/     2B8 :                     __Assembler:
     339/     2B8 : C1 FF               		ld 		-1(p1) 											; this is the operation code to use.
     340/     2BA : CE FF               		st 		@-1(p2) 										; push on the stack.
     341/     2BC :                     
     342/     2BC : 3F                  		xppc 	p3 												; evaluate (any) parameter if present
     343/     2BD : 06                  		csa 													; check carry flag set
     344/     2BE : 94 27               		jp 		__ASMNoParameter  								; if clear, no parameter was provided.
     345/     2C0 :                     
     346/     2C0 : C4 1C               		ldi 	parPosn & 255
     347/     2C2 : 31                  		xpal 	p1 												; get the parameter LSB
     348/     2C3 : CE FF               		st 		@-1(p2) 										; push that on the stack, set P1 to parPosn
     349/     2C5 : C4 0C               		ldi 	parPosn / 256
     350/     2C7 : 35                  		xpah 	p1
     351/     2C8 : C1 00               		ld 		(p1) 											; read current position
     352/     2CA : 31                  		xpal 	p1 												; P1 now points to character.
     353/     2CB : C1 00               		ld 		(p1) 											; read character
     354/     2CD : E4 21               		xri 	'!'												; is it the label pling ?
     355/     2CF : 9C 1E               		jnz 	__ASMContinue 									; we don't need to change this pointer , we should technically.
     356/     2D1 : C2 00               		ld 		(p2) 											; read the value, which is the label number
     357/     2D3 : 03                  		scl
     358/     2D4 : FC 18               		cai 	labelCount 										; is it a valid label number
     359/     2D6 : 94 D6               		jp 		__CommandError 									; no, beep.
     360/     2D8 : C2 00               		ld 		(p2) 											; re-read the label number
     361/     2DA : 01                  		xae 													; put in E
     362/     2DB : C4 0C               		ldi 	Labels/256 										; point p1 to labels
     363/     2DD : 35                  		xpah 	p1
     364/     2DE : C4 00               		ldi 	Labels&255 
     365/     2E0 : 31                  		xpal 	p1
     366/     2E1 : C1 80               		ld 		-0x80(p1) 										; read label indexed using E.
     367/     2E3 : CA 00               		st 		(p2) 											; save as the operand
     368/     2E5 : 90 08               		jmp 	__ASMContinue 									; and continue
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 14 - 1/17/2016 15:58:10


     369/     2E7 :                     
     370/     2E7 :                     __ASMNoParameter:
     371/     2E7 : C2 00               		ld 		(p2) 											; read the pushed operation code
     372/     2E9 : D4 80               		ani 	0x80 											; is bit 7 set ?
     373/     2EB : 9C C1               		jnz 	__CommandError 									; if it is, we need a parameter
     374/     2ED : CE FF               		st 		@-1(p2) 										; push zero on the stack as a dummy parameter.
     375/     2EF :                     
     376/     2EF :                     __ASMContinue:
     377/     2EF : C4 0C               		ldi 	Current/256 									; p3 = &Current Address
     378/     2F1 : 37                  		xpah 	p3
     379/     2F2 : C4 19               		ldi 	Current&255
     380/     2F4 : 33                  		xpal 	p3
     381/     2F5 :                     
     382/     2F5 : C3 04               		ld 		modifier-Current(p3) 							; get the modifier (e.g. @,Pn etc.)
     383/     2F7 : 02                  		ccl
     384/     2F8 : F2 01               		add 	1(p2) 											; add to the opcode and write it back
     385/     2FA : CA 01               		st 		1(p2)
     386/     2FC :                     
     387/     2FC : C3 00               		ld 		(p3) 											; read current address into P1
     388/     2FE : 31                  		xpal 	p1
     389/     2FF : C3 01               		ld 		1(p3)
     390/     301 : 35                  		xpah 	p1
     391/     302 :                     
     392/     302 : C2 01               		ld 		1(p2) 											; read opcode.
     393/     304 : CD 01               		st 		@1(p1) 											; write out to current address and bump it.
     394/     306 : 94 1F               		jp 		__ASMExit 										; if +ve then no operand byte, exit.
     395/     308 :                     
     396/     308 : C2 00               		ld 		(p2) 											; read the operand byte
     397/     30A : CD 01               		st 		@1(p1) 											; write that out as well.
     398/     30C :                     
     399/     30C : C3 04               		ld 		modifier-Current(p3) 							; look at the modifier 
     400/     30E : 9C 17               		jnz 	__ASMExit 										; if non zero we don't need to do anything P0 = 00
     401/     310 : C2 01               		ld 		1(p2) 											; DLY is a special case
     402/     312 : E4 8F               		xri 	0x8F 											; where the modifier is zero but not PC relative.
     403/     314 : 98 11               		jz 		__ASMExit 												
     404/     316 :                     
     405/     316 : C1 FF               		ld 		-1(p1) 											; read operand
     406/     318 : 02                  		ccl 													; one fewer because we want the current addr+1 low
     407/     319 : FB 00               		cad 	(p3) 											; subtract the current address low.
     408/     31B : C9 FF               		st 		-1(p1) 											; write it back
     409/     31D :                     
     410/     31D : C2 01               		ld 		1(p2) 											; read opcode again
     411/     31F : D4 F0               		ani 	0xF0 											; is it 9x (a JMP command)
     412/     321 : E4 90               		xri 	0x90
     413/     323 : 9C 02               		jnz 	__ASMExit 										; if not, we are done
     414/     325 : B9 FF               		dld 	-1(p1) 											; one fewer because of the pre-increment
     415/     327 :                     __ASMExit:
     416/     327 : 31                  		xpal 	p1 												; write current address back out
     417/     328 : CB 00               		st 		(p3)
     418/     32A : 35                  		xpah 	p1
     419/     32B : CB 01               		st 		1(p3)
     420/     32D : C6 02               		ld 		@2(p2) 											; drop stack values.
     421/     32F :                     
     422/     32F : 90 0C               		jmp 	__CmdMainLoop2 									; back to command loop
     423/     331 :                     
     424/     331 :                     ; ****************************************************************************************************************
     425/     331 :                     ; ****************************************************************************************************************
     426/     331 :                     ;
     427/     331 :                     ;												Commands Section
     428/     331 :                     ;
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 15 - 1/17/2016 15:58:10


     429/     331 :                     ; ****************************************************************************************************************
     430/     331 :                     ; ****************************************************************************************************************
     431/     331 :                     
     432/     331 :                     ; ****************************************************************************************************************
     433/     331 :                     ;											A : Set Current address
     434/     331 :                     ; ****************************************************************************************************************
     435/     331 :                     
     436/     331 :                     Address_Command:
     437/     331 : 3F                  		xppc 	p3 												; get parameter if exists
     438/     332 : 3F                  		xppc 	p3 												; update current if exists.
     439/     333 : 90 08               		jmp 	__CmdMainLoop2
     440/     335 :                     
     441/     335 :                     __CmdParameterFail:
     442/     335 : C4 02               		ldi 	2 												; set the beeper on
     443/     337 : 07                  		cas
     444/     338 : 8F FF               		dly 	0xFF 											; short delay
     445/     33A : C4 00               		ldi 	0 												; set the beeper off
     446/     33C : 07                  		cas
     447/     33D :                     __CmdMainLoop2:													; and go back to the start.
     448/     33D : C4 DF               		ldi 	(CommandMainLoop-1) & 255
     449/     33F : 33                  		xpal 	p3
     450/     340 : C4 01               		ldi 	(CommandMainLoop-1) / 256
     451/     342 : 37                  		xpah 	p3
     452/     343 : 3F                  		xppc 	p3
     453/     344 :                     
     454/     344 :                     ; ****************************************************************************************************************
     455/     344 :                     ;										G : Go (Address must be specified.)
     456/     344 :                     ; ****************************************************************************************************************
     457/     344 :                     
     458/     344 :                     Go_Command:
     459/     344 : 3F                  		xppc 	p3 												; get parameter, which should exist.
     460/     345 : 06                  		csa 													; look at CY/L which is set if it was.
     461/     346 : 94 ED               		jp 		__CmdParameterFail 								; if it is clear, beep an error.
     462/     348 : 31                  		xpal 	p1 												; copy P1 to P3
     463/     349 : 33                  		xpal 	p3
     464/     34A : 35                  		xpah 	p1
     465/     34B : 37                  		xpah 	p3
     466/     34C : C7 FF               		ld 		@-1(p3) 										; fix up for pre increment
     467/     34E : 3F                  		xppc 	p3 												; call the routine.		
     468/     34F :                     __CmdMainLoop3:
     469/     34F : 90 EC               		jmp 	__CmdMainLoop2 									; re-enter monitor.
     470/     351 :                     
     471/     351 :                     ; ****************************************************************************************************************
     472/     351 :                     ;			PUT Write to tape : data mandatory, it is the byte count from the current address.
     473/     351 :                     ; ****************************************************************************************************************
     474/     351 :                     
     475/     351 :                     PutTape_Command:
     476/     351 : 3F                  		xppc 	p3 												; get the bytes to write.
     477/     352 : 06                  		csa 													; if CC, no value was provided
     478/     353 : 94 E0               		jp 		__CmdParameterFail 								; which is an error.
     479/     355 : 31                  		xpal 	p1 												; store low byte count in -1(P2)
     480/     356 : CA FF               		st 		-1(p2)
     481/     358 : 35                  		xpah 	p1 												; store high byte count in -2(P2)
     482/     359 : CA FE               		st 		-2(p2)
     483/     35B : 02                  		ccl 													; skip over the update current address
     484/     35C : 3F                  		xppc 	p3 												; this won't update current address as CY/L = 0
     485/     35D : 3F                  		xppc 	p3 												; and load the current address into P1.
     486/     35E : C4 00               		ldi 	0 												; set the output tape bit low
     487/     360 : 01                  		xae
     488/     361 : 19                  		sio
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 16 - 1/17/2016 15:58:10


     489/     362 : C4 20               		ldi 	32 												; tape leader
     490/     364 : CA FD               		st 		-3(p2)
     491/     366 :                     _PutTapeLeader:
     492/     366 : 8F FF               		dly 	0xFF
     493/     368 : BA FD               		dld 	-3(p2)
     494/     36A : 9C FA               		jnz 	_PutTapeLeader
     495/     36C :                     _PutTapeByte:													; output byte at P1
     496/     36C : C4 00               		ldi 	0 												; set output bit to 0
     497/     36E : 01                  		xae 	
     498/     36F : 19                  		sio
     499/     370 : 8F 10               		dly 	tapeDelay * 4 									; 0 continuation bit + gap between tapes with no signal 
     500/     372 : C4 01               		ldi 	0x1 											; set bit high
     501/     374 : 01                  		xae
     502/     375 : 19                  		sio 
     503/     376 : C4 00               		ldi 	0
     504/     378 : 8F 04               		dly 	tapeDelay 										; output the start bit.
     505/     37A : C5 01               		ld 		@1(p1) 											; read the byte and put it in E.
     506/     37C : 01                  		xae
     507/     37D : C4 08               		ldi 	8 												; output 8 bits
     508/     37F : CA FD               		st 		-3(p2)
     509/     381 :                     _PutTapeBit:
     510/     381 : 19                  		sio 													; output MSB and shift
     511/     382 : C4 00               		ldi 	0
     512/     384 : 8F 04               		dly 	tapeDelay 								
     513/     386 : BA FD               		dld 	-3(p2) 											; do all 8 bits.
     514/     388 : 9C F7               		jnz 	_PutTapeBit
     515/     38A : BA FF               		dld 	-1(p2) 											; decrement counter
     516/     38C : 9C DE               		jnz 	_PutTapeByte
     517/     38E : BA FE               		dld 	-2(p2) 											; note MSB goes 0 to -1 when finished.
     518/     390 : 94 DA               		jp 		_PutTapeByte
     519/     392 : C4 01               		ldi 	0x01 											; add the termination bit.
     520/     394 : 01                  		xae
     521/     395 : 19                  		sio
     522/     396 : C4 00               		ldi 	0 												; put that out.
     523/     398 : 8F 04               		dly 	TapeDelay
     524/     39A : C4 00               		ldi 	0 												; and set the leve back to 0
     525/     39C : 01                  		xae 
     526/     39D : 19                  		sio
     527/     39E :                     __CmdMainLoop4:
     528/     39E : 90 AF               		jmp 	__CmdMainLoop3
     529/     3A0 :                     
     530/     3A0 :                     __CmdParameterFail1:
     531/     3A0 : 90 93               		jmp 	__CmdParameterFail
     532/     3A2 :                     
     533/     3A2 :                     ; ****************************************************************************************************************
     534/     3A2 :                     ;						GET [addr] load tape to current position or given address.
     535/     3A2 :                     ; ****************************************************************************************************************
     536/     3A2 :                     
     537/     3A2 :                     LoadTape_Command:
     538/     3A2 : 3F                  		xppc	p3 												; get parameter
     539/     3A3 : 3F                  		xppc 	p3												; update current address
     540/     3A4 : 3F                  		xppc 	p3 												; current address to P1.
     541/     3A5 : C4 08               		ldi 	0x8 											; point P3 to the keyboard.
     542/     3A7 : 37                  		xpah 	p3
     543/     3A8 :                     __GetTapeWait:
     544/     3A8 : C3 00               		ld 		0(p3) 											; check keyboard break
     545/     3AA : D4 80               		ani 	0x80
     546/     3AC : 9C F2               		jnz 	__CmdParameterFail1
     547/     3AE : 19                  		sio 													; wait for the start bit, examine tape in.
     548/     3AF : 40                  		lde 
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 17 - 1/17/2016 15:58:10


     549/     3B0 : 94 F6               		jp 		__GetTapeWait
     550/     3B2 : 8F 06               		dly 	tapeDelay * 3 / 2 								; half way into the first bit.
     551/     3B4 : C4 08               		ldi 	8 												; read in 8 bits.
     552/     3B6 : CA FF               		st 		-1(p2)
     553/     3B8 :                     __GetTapeBits:
     554/     3B8 : 19                  		sio 													; read in one bit
     555/     3B9 : C4 00               		ldi 	0
     556/     3BB : 8F 04               		dly 	tapeDelay 										; delay to next bit
     557/     3BD : BA FF               		dld 	-1(p2) 											; read 8 bits.
     558/     3BF : 9C F7               		jnz 	__GetTapeBits 
     559/     3C1 : 40                  		lde 													; store byte at current address
     560/     3C2 : CD 01               		st 		@1(p1)
     561/     3C4 : 19                  		sio 													; read in the byte, which is zero if continuing.
     562/     3C5 : 40                  		lde  													; examine bit 7 shifted in.
     563/     3C6 : 94 E0               		jp 		__GetTapeWait 									; if zero, wait for the next start bit.
     564/     3C8 :                     __CmdMainLoop5:
     565/     3C8 : 90 D4               		jmp 	__CmdMainLoop4
     566/     3CA :                     
     567/     3CA :                     ; ****************************************************************************************************************
     568/     3CA :                     ;										L : nn Set Label to current address
     569/     3CA :                     ; ****************************************************************************************************************
     570/     3CA :                     
     571/     3CA :                     Label_Command:
     572/     3CA : 3F                  		xppc 	p3 												; get parameter
     573/     3CB : 06                  		csa 													; check it exists, CY/L must be set
     574/     3CC : 94 D2               		jp 		__CmdParameterFail1
     575/     3CE : 31                  		xpal 	p1 												; get into A
     576/     3CF : 01                  		xae 													; put into E
     577/     3D0 : 40                  		lde 													; get back
     578/     3D1 : 03                  		scl
     579/     3D2 : FC 18               		cai 	labelCount 										; check is < number of labels
     580/     3D4 : 94 CA               		jp 		__CmdParameterFail1
     581/     3D6 :                     
     582/     3D6 : C4 0C               		ldi 	Current/256 									; point P1 to current address
     583/     3D8 : 35                  		xpah 	p1
     584/     3D9 : C4 19               		ldi 	Current&255
     585/     3DB : 31                  		xpal 	p1
     586/     3DC : C1 00               		ld 		(p1) 											; read current address
     587/     3DE : 31                  		xpal 	p1 												; save in P1.Low
     588/     3DF : C4 00               		ldi 	Labels&255 										; get labels low byte in same page as current address
     589/     3E1 : 02                  		ccl
     590/     3E2 : 70                  		ade 													; add label # to it
     591/     3E3 : 31                  		xpal 	p1 												; put in P1.L and restore current address low
     592/     3E4 : C9 00               		st 		(p1) 											; store current address low in label space.
     593/     3E6 : 90 E0               		jmp 	__CmdMainLoop5 									; and exit.
     594/     3E8 :                     
     595/     3E8 :                     ; ****************************************************************************************************************
     596/     3E8 :                     ;											M :	Dump Memory
     597/     3E8 :                     ; ****************************************************************************************************************
     598/     3E8 :                     
     599/     3E8 :                     MemoryDump_Command:
     600/     3E8 : 3F                  		xppc 	p3 												; get parameter if exists
     601/     3E9 : 3F                  		xppc 	p3 												; update current if exists.
     602/     3EA : C4 07               		ldi 	7 												; print seven rows
     603/     3EC : CE FF               		st 		@-1(p2)
     604/     3EE :                     __DCLoop:
     605/     3EE : C4 05               		ldi 	(PrintAddressData-1)/256						; print one row of address and data.
     606/     3F0 : 37                  		xpah 	p3
     607/     3F1 : C4 A0               		ldi 	(PrintAddressData-1)&255
     608/     3F3 : 33                  		xpal 	p3
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 18 - 1/17/2016 15:58:10


     609/     3F4 : C4 04               		ldi 	4
     610/     3F6 : 3F                  		xppc 	p3
     611/     3F7 : C4 0C               		ldi 	Current/256 									; point P1 to current
     612/     3F9 : 35                  		xpah 	p1
     613/     3FA : C4 19               		ldi 	Current&255 
     614/     3FC : 31                  		xpal 	p1
     615/     3FD : C1 00               		ld 		0(p1) 											; add 4 to current address
     616/     3FF : 02                  		ccl
     617/     400 : F4 04               		adi 	4
     618/     402 : C9 00               		st 		0(p1)
     619/     404 : C1 01               		ld 		1(p1)
     620/     406 : F4 00               		adi 	0
     621/     408 : C9 01               		st 		1(p1)
     622/     40A : BA 00               		dld 	(p2) 											; do it 7 times
     623/     40C : 9C E0               		jnz 	__DCLoop
     624/     40E : C6 01               		ld 		@1(p2) 											; fix up stack.
     625/     410 :                     __CmdMainLoop6:
     626/     410 : 90 B6               		jmp 	__CmdMainLoop5
     627/     412 :                     
     628/     412 :                     
     629/     412 :                     ; ****************************************************************************************************************
     630/     412 :                     ;								B: Enter Bytes (no address, sequence of byte data)
     631/     412 :                     ; ****************************************************************************************************************
     632/     412 :                     
     633/     412 :                     EnterBytes_Command:
     634/     412 : C4 D3               		ldi 	(GetParameter-1) & 255 							; P3 = Get Parameter routine
     635/     414 : 33                  		xpal 	p3
     636/     415 : C4 05               		ldi 	(GetParameter-1) / 256 	
     637/     417 : 37                  		xpah 	p3
     638/     418 : 3F                  		xppc 	p3 												; get the parameter.
     639/     419 : 06                  		csa 													; look at carry
     640/     41A : 94 AC               		jp 		__CmdMainLoop5 									; carry clear, no value.
     641/     41C : C4 0C               		ldi 	Current/256 									; make P1 point to current
     642/     41E : 35                  		xpah 	p1
     643/     41F : C4 19               		ldi 	Current&255 										
     644/     421 : 31                  		xpal 	p1 												; this pulls the byte value into A
     645/     422 : 01                  		xae 													; save it in E
     646/     423 : C1 00               		ld 		0(p1) 											; copy address to save to into P3
     647/     425 : 33                  		xpal 	p3
     648/     426 : C1 01               		ld 		1(p1) 
     649/     428 : 37                  		xpah 	p3 
     650/     429 : 40                  		lde 													; get byte back
     651/     42A : CB 00               		st 		(p3) 											; save it in that location
     652/     42C : A9 00               		ild 	0(p1) 											; bump current address and go back and try again.
     653/     42E : 9C E2               		jnz 	EnterBytes_Command
     654/     430 : A9 01               		ild 	1(p1)
     655/     432 : 90 DE               		jmp 	EnterBytes_Command
     656/     434 :                     
     657/     434 :                     ; ****************************************************************************************************************
     658/     434 :                     ;											D [aaaa] Disassembler
     659/     434 :                     ; ****************************************************************************************************************
     660/     434 :                     
     661/     434 :                     Disassemble_Command:	
     662/     434 : 3F                  		xppc 	p3 												; evaluate
     663/     435 : 3F                  		xppc 	p3 												; update current if new value
     664/     436 : C4 07               		ldi 	7												; instructions to disassemble counter
     665/     438 : CE FC               		st 		@-4(p2)											; p2 + 0 = counter p2 + 1 = opcode p2 + 2 = operand
     666/     43A :                     __DAssLoop:														; p2 + 3 = opcode - base opcode.
     667/     43A : C4 05               		ldi 	(PrintAddressData-1)/256						; print Address only
     668/     43C : 37                  		xpah 	p3
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 19 - 1/17/2016 15:58:10


     669/     43D : C4 A0               		ldi 	(PrintAddressData-1)&255
     670/     43F : 33                  		xpal 	p3
     671/     440 : C4 00               		ldi 	0
     672/     442 : 3F                  		xppc 	p3
     673/     443 : C4 0C               		ldi 	Current / 256 									; point P1 to current address
     674/     445 : 35                  		xpah 	p1
     675/     446 : C4 19               		ldi 	Current & 255
     676/     448 : 31                  		xpal 	p1
     677/     449 : C1 00               		ld 		0(p1) 											; load current address into P3
     678/     44B : 33                  		xpal 	p3
     679/     44C : C1 01               		ld 		1(p1)
     680/     44E : 37                  		xpah 	p3
     681/     44F : C7 01               		ld 		@1(p3) 											; read opcode
     682/     451 : CA 01               		st 		1(p2) 											; save it
     683/     453 : 94 04               		jp 		__DAssNoOperand 								; if +ve no operand
     684/     455 : C7 01               		ld 		@1(p3) 											; read operand
     685/     457 : CA 02               		st 		2(p2) 											; save it
     686/     459 :                     __DAssNoOperand:
     687/     459 : C4 E9               		ldi 	(__CommandListEnd-3) & 255
     688/     45B : 33                  		xpal 	p3 												; update current position, setting P3 to last entry
     689/     45C : C9 00               		st 		0(p1)											; in command table.
     690/     45E : C4 07               		ldi 	(__CommandListEnd-3) / 256
     691/     460 : 37                  		xpah 	p3
     692/     461 : C9 01               		st 		1(p1)
     693/     463 :                     
     694/     463 :                     __DAssFindOpcode: 												; the table is : text (word) opcode (byte)
     695/     463 : C2 01               		ld 		1(p2) 											; get opcode
     696/     465 : E3 02               		xor 	2(p3) 											; check in the same 8 byte page.
     697/     467 : D4 F0               		ani 	0xF0
     698/     469 : 9C 0B               		jnz 	__DAssNextOpcode
     699/     46B : C2 01               		ld 		1(p2) 											; get opcode
     700/     46D : 03                  		scl
     701/     46E : FB 02               		cad 	2(p3) 											; subtract the base opcode.
     702/     470 : CA 03               		st 		3(p2) 											; save a the offset (possible)
     703/     472 : D4 E0               		ani 	0xE0 											; it needs to be 0x20 or less
     704/     474 : 98 08               		jz 		__DAssFoundOpcode 								; if >= 0 then found the correct opcode.
     705/     476 :                     __DAssNextOpcode:
     706/     476 : C7 FD               		ld 		@-3(p3) 										; go to previous entry in table
     707/     478 : 90 E9               		jmp 	__DAssFindOpcode
     708/     47A :                     
     709/     47A :                     __DAssLoop2:
     710/     47A : 90 BE               		jmp 	__DAssLoop
     711/     47C :                     __CmdMainLoop7:
     712/     47C : 90 92               		jmp 	__CmdMainLoop6
     713/     47E :                     
     714/     47E :                     __DAssFoundOpcode:
     715/     47E : C3 02               		ld 		2(p3) 											; look at opcode that matched.
     716/     480 : D4 87               		ani 	0x87 											; match with 1xxx x100
     717/     482 : E4 84               		xri 	0x84 											; which is all the immediate instructions.		
     718/     484 : 9C 04               		jnz 	__DAssNotImmediate
     719/     486 : C2 03               		ld 		3(p2) 											; only do immediate if base offset is zero
     720/     488 : 9C EC               		jnz 	__DAssNextOpcode 								; fixes C0-C7 being LD, but C4 being LDI.
     721/     48A :                     __DAssNotImmediate:
     722/     48A : C3 00               		ld 		0(p3) 											; save LSB of text on stack
     723/     48C : CE FF               		st 		@-1(p2)
     724/     48E : C3 01               		ld 		1(p3) 											; and the MSB of text on stack
     725/     490 : CE FF               		st 		@-1(p2)
     726/     492 :                     
     727/     492 : C4 05               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
     728/     494 : 37                  		xpah 	p3
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 20 - 1/17/2016 15:58:10


     729/     495 : C4 33               		ldi 	(PrintCharacter-1) & 255 
     730/     497 : 33                  		xpal 	p3
     731/     498 : C4 20               		ldi 	' '												; print a space.
     732/     49A : 3F                  		xppc 	p3
     733/     49B :                     
     734/     49B : C4 03               		ldi 	3 												; print 3 characters
     735/     49D : CE FF               		st 		@-1(p2) 										; so +0 is count, +1 = text MSB, +2 = text LSB
     736/     49F :                     __DAssPrintMnemonic:
     737/     49F : C2 01               		ld 		1(p2) 											; get text MSB which is in bits .xxxxx..
     738/     4A1 : 1C                  		sr 														; shift right twice.
     739/     4A2 : 1C                  		sr
     740/     4A3 : D4 1F               		ani 	0x1F 											; lower 5 bits only
     741/     4A5 : 98 04               		jz 		__DAssSkipSpace 								; don't print spaces (00000)
     742/     4A7 : 02                  		ccl 													; make it 7 bit ASCII code.
     743/     4A8 : F4 40               		adi 	64 							
     744/     4AA : 3F                  		xppc 	p3 												; display the character
     745/     4AB :                     __DAssSkipSpace:
     746/     4AB : C4 05               		ldi 	5 												; now shift the encoded data left 5 times
     747/     4AD : CA FF               		st 		-1(p2)
     748/     4AF :                     __DAssShiftEncode:
     749/     4AF : 02                  		ccl
     750/     4B0 : C2 02               		ld 		2(p2)
     751/     4B2 : F2 02               		add 	2(p2)
     752/     4B4 : CA 02               		st 		2(p2)
     753/     4B6 : C2 01               		ld 		1(p2)
     754/     4B8 : F2 01               		add 	1(p2)
     755/     4BA : CA 01               		st 		1(p2)
     756/     4BC : BA FF               		dld 	-1(p2)
     757/     4BE : 9C EF               		jnz 	__DAssShiftEncode
     758/     4C0 : BA 00               		dld 	0(p2) 											; done all three characters
     759/     4C2 : 9C DB               		jnz 	__DAssPrintMnemonic 							; if not keep going.
     760/     4C4 :                     
     761/     4C4 : C6 03               		ld 		@3(p2) 											; remove mnemonic stuff off the stack.
     762/     4C6 :                     
     763/     4C6 : C2 03               		ld 		3(p2) 											; print instruction modifier if required.
     764/     4C8 : 9C 1F               		jnz 	__DAssPrintModifier
     765/     4CA :                     
     766/     4CA :                     __DAssPrintOperand:
     767/     4CA : C2 01               		ld 		1(p2) 											; get original opcode
     768/     4CC : 94 0A               		jp 		__DAssNext 										; if no operand go to next line of disassembly.
     769/     4CE : C4 05               		ldi 	(PrintHexByte-1) / 256 							; set P3 to point to the hex printer
     770/     4D0 : 37                  		xpah 	p3
     771/     4D1 : C4 00               		ldi 	(PrintHexByte-1) & 255
     772/     4D3 : 33                  		xpal 	p3
     773/     4D4 : C2 02               		ld 		2(p2) 											; get operand
     774/     4D6 : 03                  		scl 
     775/     4D7 : 3F                  		xppc 	p3 												; print it out with a leading space.
     776/     4D8 :                     
     777/     4D8 :                     __DAssNext:
     778/     4D8 : C4 05               		ldi 	(PrintCharacter-1) / 256 						; set P3 up to print characters
     779/     4DA : 37                  		xpah 	p3
     780/     4DB : C4 33               		ldi 	(PrintCharacter-1) & 255 
     781/     4DD : 33                  		xpal 	p3
     782/     4DE : C4 0D               		ldi 	13												; print a newline.
     783/     4E0 : 3F                  		xppc 	p3
     784/     4E1 :                     
     785/     4E1 : BA 00               		dld 	0(p2) 											; done all 6 lines
     786/     4E3 : 9C 95               		jnz 	__DAssLoop2 									; no, go round again.
     787/     4E5 : C6 04               		ld 		@4(p2) 											; fix up the stack.
     788/     4E7 : 90 93               		jmp 	__CmdMainLoop7 									; and time to exit.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 21 - 1/17/2016 15:58:10


     789/     4E9 :                     
     790/     4E9 :                     
     791/     4E9 :                     __DAssPrintModifier:
     792/     4E9 : C4 20               		ldi 	' '												; print leading space
     793/     4EB : 3F                  		xppc 	p3
     794/     4EC : C2 03               		ld 		3(p2) 											; read modifier
     795/     4EE : D4 04               		ani 	0x04 											; is @ bit set
     796/     4F0 : 98 03               		jz 		__DAssNotAutoIndexed
     797/     4F2 : C4 40               		ldi 	'@'												; print '@'
     798/     4F4 : 3F                  		xppc 	p3
     799/     4F5 :                     __DAssNotAutoIndexed:
     800/     4F5 : C4 50               		ldi 	'P'												; print 'P'
     801/     4F7 : 3F                  		xppc 	p3
     802/     4F8 : C2 03               		ld 		3(p2) 											; print pointer register
     803/     4FA : D4 03               		ani 	3
     804/     4FC : DC 30               		ori 	'0'
     805/     4FE : 3F                  		xppc 	p3
     806/     4FF : 90 C9               		jmp 	__DAssPrintOperand 								; and print operand.
     807/     501 :                     
     808/     501 :                     
     809/     501 :                     ; ****************************************************************************************************************
     810/     501 :                     ; ****************************************************************************************************************
     811/     501 :                     ;
     812/     501 :                     ;						Print A as a hexadecimal 2 digit value. If CY/L set precede with space
     813/     501 :                     ;
     814/     501 :                     ; ****************************************************************************************************************
     815/     501 :                     ; ****************************************************************************************************************
     816/     501 :                     
     817/     501 :                     PrintHexByte:
     818/     501 : CE FF               		st 		@-1(p2) 										; push A and P3, set P3 up to print character
     819/     503 : C4 05               		ldi 	(PrintCharacter-1)/256
     820/     505 : 37                  		xpah 	p3
     821/     506 : CE FF               		st 		@-1(p2)
     822/     508 : C4 33               		ldi 	(PrintCharacter-1)&255
     823/     50A : 33                  		xpal 	p3
     824/     50B : CE FF               		st 		@-1(p2)
     825/     50D : 06                  		csa 													; check carry
     826/     50E : 94 03               		jp 		__PHBNoSpace									; if clear, no space.
     827/     510 : C4 20               		ldi 	' '												; print leading space
     828/     512 : 3F                  		xppc 	p3 
     829/     513 :                     __PHBNoSpace:
     830/     513 : C2 02               		ld 		2(p2) 											; read digit
     831/     515 : 1C                  		sr 														; convert MSB
     832/     516 : 1C                  		sr
     833/     517 : 1C                  		sr
     834/     518 : 1C                  		sr
     835/     519 : 02                  		ccl
     836/     51A : EC 90               		dai 	0x90
     837/     51C : EC 40               		dai 	0x40
     838/     51E : 3F                  		xppc 	p3 												; print
     839/     51F : C2 02               		ld 		2(p2) 											; read digit
     840/     521 : D4 0F               		ani 	0x0F 											; convert LSB
     841/     523 : 02                  		ccl
     842/     524 : EC 90               		dai 	0x90
     843/     526 : EC 40               		dai 	0x40
     844/     528 : 3F                  		xppc 	p3 												; print
     845/     529 :                     
     846/     529 : C6 01               		ld 		@1(p2) 											; restore P3 & A and Return
     847/     52B : 33                  		xpal 	p3
     848/     52C : C6 01               		ld 		@1(p2)
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 22 - 1/17/2016 15:58:10


     849/     52E : 37                  		xpah 	p3
     850/     52F : C6 01               		ld 		@1(p2)
     851/     531 : 3F                  		xppc 	p3
     852/     532 : 90 CD               		jmp 	PrintHexByte
     853/     534 :                     
     854/     534 :                     ; ****************************************************************************************************************
     855/     534 :                     ; ****************************************************************************************************************
     856/     534 :                     ;
     857/     534 :                     ;		Print Character in A, preserves all registers, re-entrant. Handles 13 (New Line), 8 (Backspace)
     858/     534 :                     ;		Characters 32 - 95 only.
     859/     534 :                     ;	
     860/     534 :                     ;		Rolls to screen top rather than scrolling.
     861/     534 :                     ;
     862/     534 :                     ; ****************************************************************************************************************
     863/     534 :                     ; ****************************************************************************************************************
     864/     534 :                     
     865/     534 :                     PrintCharacter:
     866/     534 : CE FF               		st 		@-1(p2) 										; save A
     867/     536 : C4 0C               		ldi 	Cursor/256 										; save P1, setting up P1 -> Cursor at same time.
     868/     538 : 35                  		xpah 	p1
     869/     539 : CE FF               		st 		@-1(p2)
     870/     53B : C4 18               		ldi 	Cursor&255
     871/     53D : 31                  		xpal 	p1
     872/     53E : CE FF               		st 		@-1(p2)
     873/     540 : C4 00               		ldi 	0 												; save P3, setting up P3 -> Page 0 (Video RAM Write)
     874/     542 : 37                  		xpah 	p3
     875/     543 : CE FF               		st 		@-1(p2)
     876/     545 : 33                  		xpal 	p3
     877/     546 : CE FF               		st 		@-1(p2)
     878/     548 :                     
     879/     548 : C1 00               		ld 		(p1) 											; read cursor position
     880/     54A : 33                  		xpal 	p3 												; put in P3.Low
     881/     54B :                     
     882/     54B : C4 20               		ldi 	' ' 											; erase the cursor.
     883/     54D : CB 00               		st 		0(p3)
     884/     54F :                     
     885/     54F : C2 04               		ld 		4(p2) 											; read character to print.
     886/     551 : E4 0D               		xri 	13 												; is it CR ?
     887/     553 : 98 40               		jz 		__PCNewLine 									; if so, go to new line.
     888/     555 : E4 05               		xri 	13!8 											; is it Backspace ?
     889/     557 : 98 30               		jz 		__PCBackSpace
     890/     559 :                     
     891/     559 : C2 04               		ld 		4(p2) 											; get character to print
     892/     55B : D4 3F               		ani 	0x3F 											; make 6 bit ASCII
     893/     55D : CF 01               		st 		@1(p3) 											; write into P3, e.g. the screen and bump it.
     894/     55F : A9 00               		ild 	(p1) 											; increment cursor position and load
     895/     561 : D4 0F               		ani 	15 												; are we at line start ?
     896/     563 : 9C 0C               		jnz 	__PCExit 										; if so, erase the current line.
     897/     565 :                     
     898/     565 :                     __PCBlankNewLine:
     899/     565 : C4 10               		ldi 	16 												; count to 16, the number of spaces to write out.
     900/     567 : CA FF               		st 		-1(p2) 
     901/     569 :                     __PCBlankNewLineLoop:
     902/     569 : C4 20               		ldi 	' '
     903/     56B : CF 01               		st 		@1(p3)
     904/     56D : BA FF               		dld 	-1(p2)
     905/     56F : 9C F8               		jnz 	__PCBlankNewLineLoop
     906/     571 :                     
     907/     571 :                     __PCExit:
     908/     571 : C1 00               		ld 		(p1) 											; read cursor
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 23 - 1/17/2016 15:58:10


     909/     573 : 33                  		xpal 	p3 												; put in P3.L
     910/     574 : C4 9B               		ldi 	0x9B 											; shaded block cursor on screen
     911/     576 : CB 00               		st 		(p3)
     912/     578 : C6 01               		ld 		@1(p2)											; restore P3
     913/     57A : 33                  		xpal 	p3
     914/     57B : C6 01               		ld 		@1(p2)
     915/     57D : 37                  		xpah 	p3
     916/     57E : C6 01               		ld 		@1(p2)											; restore P1
     917/     580 : 31                  		xpal 	p1
     918/     581 : C6 01               		ld 		@1(p2)
     919/     583 : 35                  		xpah 	p1
     920/     584 : C6 01               		ld 		@1(p2) 											; restore A and Return.	
     921/     586 : 3F                  		xppc 	p3
     922/     587 : 90 AB               		jmp 	PrintCharacter 									; and it is re-entrant.
     923/     589 :                     
     924/     589 :                     __PCBackSpace:
     925/     589 : 33                  		xpal 	p3 												; get current cursor position
     926/     58A : 98 E5               		jz 		__PCExit 										; if top of screen then exit.
     927/     58C : B9 00               		dld 	(p1) 											; backspace and load cursor
     928/     58E : 33                  		xpal 	p3 												; put in P3
     929/     58F : C4 20               		ldi 	' '												; erase character there
     930/     591 : CB 00               		st 		(p3)
     931/     593 : 90 DC               		jmp 	__PCExit 										; and exit.
     932/     595 :                     
     933/     595 :                     __PCNewLine:
     934/     595 : C1 00               		ld 		(p1) 											; read cursor position
     935/     597 : D4 70               		ani 	0x70 											; line
     936/     599 : 02                  		ccl 													; next line
     937/     59A : F4 10               		adi 	0x10
     938/     59C : C9 00               		st 		(p1) 											; write back
     939/     59E : 33                  		xpal 	p3 												; put in P3.L
     940/     59F : 90 C4               		jmp 	__PCBlankNewLine
     941/     5A1 :                     
     942/     5A1 :                     ; ****************************************************************************************************************
     943/     5A1 :                     ; ****************************************************************************************************************
     944/     5A1 :                     ;
     945/     5A1 :                     ;					Print current address followed by A data bytes. Doesn't update current address
     946/     5A1 :                     ;
     947/     5A1 :                     ; ****************************************************************************************************************
     948/     5A1 :                     ; ****************************************************************************************************************
     949/     5A1 :                     
     950/     5A1 :                     PrintAddressData:
     951/     5A1 : CE FF               		st 		@-1(p2) 										; save count, we don't restore this.
     952/     5A3 : C4 05               		ldi 	(PrintHexByte-1)/256 							; save and set up P3
     953/     5A5 : 37                  		xpah 	p3
     954/     5A6 : CE FF               		st 		@-1(p2)
     955/     5A8 : C4 00               		ldi 	(PrintHexByte-1)&255
     956/     5AA : 33                  		xpal 	p3
     957/     5AB : CE FF               		st 		@-1(p2)
     958/     5AD : C4 0C               		ldi 	current / 256 									; point P1 to current address
     959/     5AF : 35                  		xpah 	p1
     960/     5B0 : C4 19               		ldi 	current & 255
     961/     5B2 : 31                  		xpal 	p1
     962/     5B3 : C1 01               		ld 		1(p1) 											; read high byte of address
     963/     5B5 : 02                  		ccl
     964/     5B6 : 3F                  		xppc 	p3												; print w/o leading space
     965/     5B7 : C1 00               		ld 		0(p1)											; read low byte of address
     966/     5B9 : 02                  		ccl 	
     967/     5BA : 3F                  		xppc 	p3 												; print w/o leading space.
     968/     5BB : 01                  		xae 													; put in E
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 24 - 1/17/2016 15:58:10


     969/     5BC : C1 01               		ld 		1(p1) 											; high byte to P1.H
     970/     5BE : 35                  		xpah 	p1
     971/     5BF : 40                  		lde 													; low byte to P1.H
     972/     5C0 : 31                  		xpal 	p1
     973/     5C1 :                     _PADLoop:
     974/     5C1 : BA 02               		dld 	2(p2) 											; decrement counter
     975/     5C3 : 94 09               		jp 		_PADPrint 										; if +ve print another byte
     976/     5C5 :                     
     977/     5C5 : C6 01               		ld 		@1(p2) 											; restore P3, skipping A hence @2
     978/     5C7 : 33                  		xpal 	p3
     979/     5C8 : C6 02               		ld 		@2(p2)
     980/     5CA : 37                  		xpah 	p3
     981/     5CB : 3F                  		xppc 	p3
     982/     5CC : 90 D3               		jmp 	PrintAddressData
     983/     5CE :                     
     984/     5CE :                     _PADPrint:
     985/     5CE : C5 01               		ld 		@1(p1) 											; read byte advance pointer
     986/     5D0 : 03                  		scl
     987/     5D1 : 3F                  		xppc 	p3 												; print with space.
     988/     5D2 : 90 ED               		jmp 	_PADLoop
     989/     5D4 :                     
     990/     5D4 :                     ; ****************************************************************************************************************
     991/     5D4 :                     ;
     992/     5D4 :                     ;		Look at the parameter string for a parameter, processing @ and Pn as you go, CS if parameter found
     993/     5D4 :                     ; 		CC otherwise. Return parameter value in P1. Falls through
     994/     5D4 :                     ;
     995/     5D4 :                     ; ****************************************************************************************************************
     996/     5D4 :                     
     997/     5D4 :                     GetParameter:
     998/     5D4 : C4 0C               		ldi 	parPosn/256 									; current position into P1
     999/     5D6 : 35                  		xpah 	p1
    1000/     5D7 : C4 1C               		ldi 	parPosn&255 					
    1001/     5D9 : 31                  		xpal 	p1
    1002/     5DA : C4 00               		ldi 	0 												; -1(p2) is the low byte result
    1003/     5DC : CA FF               		st 		-1(p2) 											; -2(p2) is the high byte result
    1004/     5DE : CA FE               		st 		-2(p2)
    1005/     5E0 :                     
    1006/     5E0 : C1 00               		ld 		(p1) 											; read the current position,P1 points to character
    1007/     5E2 : 31                  		xpal 	p1 												; when we put it in P1.L
    1008/     5E3 :                     
    1009/     5E3 :                     __GPASkip:														; skip over spaces to first alphanumeric.
    1010/     5E3 : C1 00               		ld 		(p1) 											; read character
    1011/     5E5 : 98 7B               		jz 		__GPAExitFail 									; if zero, then end of the input string.
    1012/     5E7 : C5 01               		ld 		@1(p1) 											; read it, advancing.
    1013/     5E9 : E4 20               		xri 	32 												; is it space ?
    1014/     5EB : 98 F6               		jz 		__GPASkip 
    1015/     5ED : E4 60               		xri 	32!'@'											; is it @ ?
    1016/     5EF : 98 5E               		jz 		__GPAAtModifier 
    1017/     5F1 : E4 10               		xri 	'@'!'P' 										; is it P ?
    1018/     5F3 : 98 4C               		jz 		__GPAPointerModifier
    1019/     5F5 :                     
    1020/     5F5 :                     __GPANextCharacter:
    1021/     5F5 : C1 FF               		ld 		-1(p1) 											; get value back after post increment.
    1022/     5F7 : 02                  		ccl
    1023/     5F8 : F4 50               		adi 	128-48 											; this will be +ve if A < '0'
    1024/     5FA : 94 66               		jp 		__GPAExitFail
    1025/     5FC : FC 09               		cai 	9 												; will be +ve if A < '9', CY/L was clear.	
    1026/     5FE : 94 0A               		jp 		__GPAFoundHex
    1027/     600 : FC 07               		cai 	7 												; will be +ve if A < 'A', CY/L was set
    1028/     602 : 94 5E               		jp 		__GPAExitFail
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 25 - 1/17/2016 15:58:10


    1029/     604 : F4 79               		adi 	0xFF-0x85-1 									; will be +ve if A > 'F', CY/L was set.
    1030/     606 : 94 5A               		jp 		__GPAExitFail 					
    1031/     608 : F4 76               		adi 	(0x70-0xFA) & 0xFF 								; make the range as below, CY/L was clear
    1032/     60A :                     __GPAFoundHex: 													; enter here 0-9 = $76..$7F, A-F = $70..$75
    1033/     60A : 02                  		ccl  													; convert that to a hex nibble.
    1034/     60B : F4 0A               		adi 	10
    1035/     60D : D4 0F               		ani 	0xF
    1036/     60F : 01                  		xae 													; save in E, temporarily
    1037/     610 : C4 04               		ldi 	4 												; now shift the result 4 bits to the left.
    1038/     612 : CA FD               		st 		-3(p2) 											; -3(p2) is the counter
    1039/     614 :                     __GPAShift:
    1040/     614 : 02                  		ccl
    1041/     615 : C2 FF               		ld 		-1(p2) 											; shift 16 bit result 1 bit to the left.
    1042/     617 : F2 FF               		add 	-1(p2)
    1043/     619 : CA FF               		st 		-1(p2)
    1044/     61B : C2 FE               		ld 		-2(p2)
    1045/     61D : F2 FE               		add 	-2(p2)
    1046/     61F : CA FE               		st 		-2(p2)
    1047/     621 : BA FD               		dld 	-3(p2) 											; do it four times
    1048/     623 : 9C EF               		jnz 	__GPAShift 	
    1049/     625 : C2 FF               		ld 		-1(p2) 											; Or E into the LSB
    1050/     627 : 58                  		ore
    1051/     628 : CA FF               		st 		-1(p2)
    1052/     62A :                     
    1053/     62A : C5 01               		ld 		@1(p1) 											; look at next character, post incrementing.
    1054/     62C : 03                  		scl
    1055/     62D : FC 22               		cai 	34 												; if it is after space and ! (label marker)
    1056/     62F : 94 C4               		jp 		__GPANextCharacter 								; go back and put it in place.
    1057/     631 :                     
    1058/     631 : C5 FF               		ld 		@-1(p1) 										; undo the increment, incase we've just read zero.
    1059/     633 :                     
    1060/     633 : C4 1C               		ldi 	parPosn & 255 									; put the parPosn address in P1.L, new posn into A
    1061/     635 : 31                  		xpal 	p1
    1062/     636 : C9 00               		st 		(p1) 											; and write it back
    1063/     638 : C2 FF               		ld 		-1(p2) 											; put the result into P1
    1064/     63A : 31                  		xpal 	p1
    1065/     63B : C2 FE               		ld 		-2(p2)
    1066/     63D : 35                  		xpah 	p1
    1067/     63E : 03                  		scl 													; set CY/L to indicate okay
    1068/     63F : 90 22               		jmp 	__GPAExit
    1069/     641 :                     
    1070/     641 :                     __GPAPointerModifier:
    1071/     641 : C1 00               		ld 		(p1) 											; read P<something> ?
    1072/     643 : D4 FC               		ani 	0xFC 											; is it '0' .. '3'?
    1073/     645 : E4 30               		xri 	'0'
    1074/     647 : 9C 19               		jnz 	__GPAExitFail 									; it didn't work, not 0..3
    1075/     649 : C5 01               		ld 		@1(p1) 											; re-read it and advance
    1076/     64B : D4 03               		ani 	3												; lower 2 bits only
    1077/     64D : 90 02               		jmp 	__GPAAdjustModifier
    1078/     64F :                     __GPAAtModifier:
    1079/     64F : C4 04               		ldi 	4 												; set modifier adjustment to +4
    1080/     651 :                     __GPAAdjustModifier:
    1081/     651 : CA FD               		st 		-3(p2) 
    1082/     653 : C4 1D               		ldi 	modifier & 255 									; point P1 to modifier, save current address in E
    1083/     655 : 31                  		xpal 	p1
    1084/     656 : 01                  		xae 
    1085/     657 : C1 00               		ld 		(p1) 											; read modifier
    1086/     659 : 02                  		ccl
    1087/     65A : F2 FD               		add 	-3(p2) 											; add the modifying value to it.
    1088/     65C : C9 00               		st 		(p1) 											; write modifier.
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 26 - 1/17/2016 15:58:10


    1089/     65E : 40                  		lde 													; restore current address to P1.L
    1090/     65F : 31                  		xpal 	p1
    1091/     660 : 90 81               		jmp 	__GPASkip 										; go back to skip over.
    1092/     662 :                     
    1093/     662 :                     __GPAExitFail:
    1094/     662 : 02                  		ccl 													; carry clear, e.g. nothing read in / error.
    1095/     663 :                     __GPAExit:
    1096/     663 : 3F                  		xppc 	p3
    1097/     664 :                     
    1098/     664 :                     ; ****************************************************************************************************************
    1099/     664 :                     ;
    1100/     664 :                     ;		Store parameter value in P1 in the current address, if CS. Falls through.
    1101/     664 :                     ;
    1102/     664 :                     ; ****************************************************************************************************************
    1103/     664 :                     
    1104/     664 :                     UpdateCurrentAddress:
    1105/     664 : 06                  		csa 													; get status reg
    1106/     665 : 94 0C               		jp 		__UCAExit 										; if carry flag clear then exit.
    1107/     667 :                     
    1108/     667 : C4 19               		ldi 	current & 255 									; current address to P1.L, acquired address to E
    1109/     669 : 31                  		xpal 	p1
    1110/     66A : 01                  		xae
    1111/     66B : C4 0C               		ldi 	current / 256 									; current address to P1.H, acquired to A
    1112/     66D : 35                  		xpah 	p1
    1113/     66E : C9 01               		st 		1(p1) 											; store address back
    1114/     670 : 40                  		lde
    1115/     671 : C9 00               		st 		0(p1)
    1116/     673 :                     __UCAExit:
    1117/     673 : 3F                  		xppc 	p3
    1118/     674 :                     
    1119/     674 :                     ; ****************************************************************************************************************
    1120/     674 :                     ;
    1121/     674 :                     ;		Get current address into P1.
    1122/     674 :                     ;
    1123/     674 :                     ; ****************************************************************************************************************
    1124/     674 :                     
    1125/     674 :                     GetCurrentAddress:
    1126/     674 : C4 0C               		ldi 	current/256 									; current address ptr in P1
    1127/     676 : 35                  		xpah 	p1
    1128/     677 : C4 19               		ldi 	current&255
    1129/     679 : 31                  		xpal 	p1
    1130/     67A : C1 00               		ld 		0(p1) 											; low byte to E
    1131/     67C : 01                  		xae
    1132/     67D : C1 01               		ld 		1(p1) 											; high byte to A
    1133/     67F : 35                  		xpah 	p1 												; then to P1.H
    1134/     680 : 40                  		lde 													; low byte to P1.L
    1135/     681 : 31                  		xpal 	p1 
    1136/     682 : 3F                  		xppc 	p3
    1137/     683 :                     
    1138/     683 :                     ; ****************************************************************************************************************
    1139/     683 :                     ;
    1140/     683 :                     ;											List of commands and Jump Table
    1141/     683 :                     ;
    1142/     683 :                     ; ****************************************************************************************************************
    1143/     683 :                     
    1144/     683 :                     		include commands.inc 									; must be at the end, so the command table is in
(1)    1/     747 :                             org 0x0747
(1)    2/     747 :                     ;
(1)    3/     747 :                     ; 	This file is generated automatically by gencommands.py
(1)    4/     747 :                     ;
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 27 - 1/17/2016 15:58:10


(1)    5/     747 :                     __CommandList:
(1)    6/     747 : 94 21                       dw    0x2194 ; HLT
(1)    7/     749 : 00                          db    0x00
(1)    8/     74A : 25 60                       dw    0x6025 ; XAE
(1)    9/     74C : 01                          db    0x01
(1)   10/     74D : 6C 0C                       dw    0x0c6c ; CCL
(1)   11/     74F : 02                          db    0x02
(1)   12/     750 : 6C 4C                       dw    0x4c6c ; SCL
(1)   13/     752 : 03                          db    0x03
(1)   14/     753 : 2E 11                       dw    0x112e ; DIN
(1)   15/     755 : 04                          db    0x04
(1)   16/     756 : AE 24                       dw    0x24ae ; IEN
(1)   17/     758 : 05                          db    0x05
(1)   18/     759 : 61 0E                       dw    0x0e61 ; CSA
(1)   19/     75B : 06                          db    0x06
(1)   20/     75C : 33 0C                       dw    0x0c33 ; CAS
(1)   21/     75E : 07                          db    0x07
(1)   22/     75F : F0 39                       dw    0x39f0 ; NOP
(1)   23/     761 : 08                          db    0x08
(1)   24/     762 : 2F 4D                       dw    0x4d2f ; SIO
(1)   25/     764 : 19                          db    0x19
(1)   26/     765 : 72 02                       dw    0x0272 ; SR
(1)   27/     767 : 1C                          db    0x1c
(1)   28/     768 : 4C 4E                       dw    0x4e4c ; SRL
(1)   29/     76A : 1D                          db    0x1d
(1)   30/     76B : 52 02                       dw    0x0252 ; RR
(1)   31/     76D : 1E                          db    0x1e
(1)   32/     76E : 4C 4A                       dw    0x4a4c ; RRL
(1)   33/     770 : 1F                          db    0x1f
(1)   34/     771 : 0D 00                       dw    0x000d ; M
(1)   35/     773 : 20                          db    0x20
(1)   36/     774 : 01 00                       dw    0x0001 ; A
(1)   37/     776 : 21                          db    0x21
(1)   38/     777 : 07 00                       dw    0x0007 ; G
(1)   39/     779 : 22                          db    0x22
(1)   40/     77A : B4 42                       dw    0x42b4 ; PUT
(1)   41/     77C : 23                          db    0x23
(1)   42/     77D : B4 1C                       dw    0x1cb4 ; GET
(1)   43/     77F : 24                          db    0x24
(1)   44/     780 : 03 00                       dw    0x0003 ; C
(1)   45/     782 : 25                          db    0x25
(1)   46/     783 : 02 00                       dw    0x0002 ; B
(1)   47/     785 : 26                          db    0x26
(1)   48/     786 : 0C 00                       dw    0x000c ; L
(1)   49/     788 : 27                          db    0x27
(1)   50/     789 : 04 00                       dw    0x0004 ; D
(1)   51/     78B : 28                          db    0x28
(1)   52/     78C : 0C 62                       dw    0x620c ; XPL
(1)   53/     78E : 30                          db    0x30
(1)   54/     78F : 08 62                       dw    0x6208 ; XPH
(1)   55/     791 : 34                          db    0x34
(1)   56/     792 : 03 62                       dw    0x6203 ; XPC
(1)   57/     794 : 3C                          db    0x3c
(1)   58/     795 : 85 30                       dw    0x3085 ; LDE
(1)   59/     797 : 40                          db    0x40
(1)   60/     798 : C5 05                       dw    0x05c5 ; ANE
(1)   61/     79A : 50                          db    0x50
(1)   62/     79B : 45 3E                       dw    0x3e45 ; ORE
(1)   63/     79D : 58                          db    0x58
(1)   64/     79E : 45 62                       dw    0x6245 ; XRE
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 28 - 1/17/2016 15:58:10


(1)   65/     7A0 : 60                          db    0x60
(1)   66/     7A1 : 25 10                       dw    0x1025 ; DAE
(1)   67/     7A3 : 68                          db    0x68
(1)   68/     7A4 : 85 04                       dw    0x0485 ; ADE
(1)   69/     7A6 : 70                          db    0x70
(1)   70/     7A7 : 25 0C                       dw    0x0c25 ; CAE
(1)   71/     7A9 : 78                          db    0x78
(1)   72/     7AA : 99 11                       dw    0x1199 ; DLY
(1)   73/     7AC : 8F                          db    0x8f
(1)   74/     7AD : B0 29                       dw    0x29b0 ; JMP
(1)   75/     7AF : 90                          db    0x90
(1)   76/     7B0 : 50 01                       dw    0x0150 ; JP
(1)   77/     7B2 : 94                          db    0x94
(1)   78/     7B3 : 5A 01                       dw    0x015a ; JZ
(1)   79/     7B5 : 98                          db    0x98
(1)   80/     7B6 : DA 29                       dw    0x29da ; JNZ
(1)   81/     7B8 : 9C                          db    0x9c
(1)   82/     7B9 : 84 25                       dw    0x2584 ; ILD
(1)   83/     7BB : A8                          db    0xa8
(1)   84/     7BC : 84 11                       dw    0x1184 ; DLD
(1)   85/     7BE : B8                          db    0xb8
(1)   86/     7BF : 84 01                       dw    0x0184 ; LD
(1)   87/     7C1 : C0                          db    0xc0
(1)   88/     7C2 : 89 30                       dw    0x3089 ; LDI
(1)   89/     7C4 : C4                          db    0xc4
(1)   90/     7C5 : 74 02                       dw    0x0274 ; ST
(1)   91/     7C7 : C8                          db    0xc8
(1)   92/     7C8 : C4 05                       dw    0x05c4 ; AND
(1)   93/     7CA : D0                          db    0xd0
(1)   94/     7CB : C9 05                       dw    0x05c9 ; ANI
(1)   95/     7CD : D4                          db    0xd4
(1)   96/     7CE : F2 01                       dw    0x01f2 ; OR
(1)   97/     7D0 : D8                          db    0xd8
(1)   98/     7D1 : 49 3E                       dw    0x3e49 ; ORI
(1)   99/     7D3 : DC                          db    0xdc
(1)  100/     7D4 : F2 61                       dw    0x61f2 ; XOR
(1)  101/     7D6 : E0                          db    0xe0
(1)  102/     7D7 : 49 62                       dw    0x6249 ; XRI
(1)  103/     7D9 : E4                          db    0xe4
(1)  104/     7DA : 24 10                       dw    0x1024 ; DAD
(1)  105/     7DC : E8                          db    0xe8
(1)  106/     7DD : 29 10                       dw    0x1029 ; DAI
(1)  107/     7DF : EC                          db    0xec
(1)  108/     7E0 : 84 04                       dw    0x0484 ; ADD
(1)  109/     7E2 : F0                          db    0xf0
(1)  110/     7E3 : 89 04                       dw    0x0489 ; ADI
(1)  111/     7E5 : F4                          db    0xf4
(1)  112/     7E6 : 24 0C                       dw    0x0c24 ; CAD
(1)  113/     7E8 : F8                          db    0xf8
(1)  114/     7E9 : 29 0C                       dw    0x0c29 ; CAI
(1)  115/     7EB : FC                          db    0xfc
(1)  116/     7EC :                     __CommandListEnd:
(1)  117/     7EC : 00 00                       dw    0x0000 ; End Marker	
(1)  118/     7EE :                     
(1)  119/     7EE :                     __CommandTable:
(1)  120/     7EE : E8 03                       dw    MemoryDump_Command
(1)  121/     7F0 : 31 03                       dw    Address_Command
(1)  122/     7F2 : 44 03                       dw    Go_Command
(1)  123/     7F4 : 51 03                       dw    PutTape_Command
(1)  124/     7F6 : A2 03                       dw    LoadTape_Command
 AS V1.42 Beta [Bld 102] - source file monitor.asm(commands.inc) - page 29 - 1/17/2016 15:58:10


(1)  125/     7F8 : 78 01                       dw    ClearScreen_Command
(1)  126/     7FA : 12 04                       dw    EnterBytes_Command
(1)  127/     7FC : CA 03                       dw    Label_Command
(1)  128/     7FE : 34 04                       dw    Disassemble_Command
(1)  129/     800 :                     
    1145/     800 :                     																; the same page.
    1146/     800 :                     
    1147/     800 :                     ; ****************************************************************************************************************
    1148/     800 :                     ;
    1149/     800 :                     ;													Tape Format. 
    1150/     800 :                     ;
    1151/     800 :                     ; ****************************************************************************************************************
    1152/     800 :                     ;
    1153/     800 :                     ;		1 x start bit 		'1' value is held for period of time.
    1154/     800 :                     ;		8 x data bits  		'0 or 1' value is held for a period of time.
    1155/     800 :                     ;		1 x continuation	'0' if another bit follows, '1' if end.
    1156/     800 :                     ;		at least 2 bit times between bytes.
    1157/     800 :                     ;
    1158/     800 :                     ;		Use DLY 4 with A = 0 (DLY 6 to skip half-start)
    1159/     800 :                     ; 		= 13 + 2 * 0 + 514 * 4 microcycles
    1160/     800 :                     ;		= 2,069 microcycles
    1161/     800 :                     ;	
    1162/     800 :                     ;		which is about 240 bits per second.
    1163/     800 :                     ;
    1164/     800 :                     ; ****************************************************************************************************************
    1165/     800 :                     ;
    1166/     800 :                     ;												Monitor Commands
    1167/     800 :                     ;
    1168/     800 :                     ; ****************************************************************************************************************
    1169/     800 :                     ;
    1170/     800 :                     ;		A [aaaa] 			Set current address to aaaa
    1171/     800 :                     ;		B [cc] [dd] [ee]..	Put Bytes cc dd ee etc. in memory from current address onwards.
    1172/     800 :                     ; 		C 					Clear screen
    1173/     800 :                     ;		D [aaaa] 			Disassemble from aaaa (7 lines of disassembly)
    1174/     800 :                     ;		G aaaa 				Run from address - address must be given - return with XPPC P3
    1175/     800 :                     ; 		L n 				Set label n to the current address (up to 24 labels 00-17)
    1176/     800 :                     ; 		M [aaaa] 			Memory dump from current address/aaaa (7 lines, 4 bytes per line)
    1177/     800 :                     ; 		GET [aaaa] 			Load tape to current address/aaa
    1178/     800 :                     ;		PUT [nnnn]			Write nnnn bytes from current address onwards to tape.
    1179/     800 :                     ;
    1180/     800 :                     ;		Command Line Assembler:
    1181/     800 :                     ;
    1182/     800 :                     ;		Standard SC/MP mnemonics, except for XPAH, XPAL, XPPC, HALT and DINT which are XPH XPL XPC HLT DIN
    1183/     800 :                     ;		respectively (4 character mnemonics not supported)
    1184/     800 :                     ;
    1185/     800 :                     ;		Address modes are written as such:
    1186/     800 :                     ;
    1187/     800 :                     ;		Direct:			LD 	address 					(offset auto calculated, also for jump)
    1188/     800 :                     ;		Indexed:		LD  P1 7 						(normally ld 7(p1))
    1189/     800 :                     ;		Immediate:		DLY 42 					
    1190/     800 :                     ;		AutoIndexed:	LD @P1 4 						(normally ld @4(p1))
    1191/     800 :                     ;
    1192/     800 :                     ;		Labels are accessed via the pling, so to jump to label 4 rather than address 4 you write
    1193/     800 :                     ;
    1194/     800 :                     ;		JMP 4!
    1195/     800 :                     ;
    1196/     800 :                     ;		Documentation of the Mathematics functions are in the included file maths.asm. Sort of.
    1197/     800 :                     ;
    1198/     800 :                     ; ****************************************************************************************************************
    1199/     800 :                     
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 30 - 1/17/2016 15:58:10


 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 31 - 1/17/2016 15:58:10


  symbol table (* = unused):
  ------------------------

 ADDRESS_COMMAND :              331 C | *ARCHITECTURE :  i386-unknown-win32 - |
*BIGENDIAN :                      0 - | *BOOTMONITOR :                  15E C |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
 CLEARSCREENLOOP :              17D C |  CLEARSCREEN_COMMAND :          178 C |
 CODESTART :                    C2E - |  COMMANDMAINLOOP :              1E0 C |
*CONSTPI :        3.141592653589793 - |  CURRENT :                      C19 - |
 CURSOR :                       C18 - | *DATE :                   1/17/2016 - |
 DISASSEMBLE_COMMAND :          434 C |  ENTERBYTES_COMMAND :           412 C |
 EXTRACT5BIT :                  24B C | *FALSE :                          0 - |
 FINDTOPMEMORY :                170 C | *FULLPMMU :                       1 - |
 GETCHAR :                       10 C | *GETCURRENTADDRESS :            674 C |
 GETPARAMETER :                 5D4 C |  GETSTRING :                     36 C |
 GO_COMMAND :                   344 C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
 INITIALBEEP :                  1D3 C | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - |  ISINIT :                       C1B - |
 KBDBUFFER :                    C1E - |  KBDBUFFERLN :                   10 - |
 KEYBOARDLOOP :                 1F5 C |  LABELCOUNT :                    18 - |
 LABELS :                       C00 - |  LABEL_COMMAND :                3CA C |
*LISTON :                         1 - |  LOADTAPE_COMMAND :             3A2 C |
*MACEXP :                         1 - |  MEMORYDUMP_COMMAND :           3E8 C |
 MESSAGE :                      1B4 C |  MESSAGELOOP :                  1AD C |
 MODIFIER :                     C1D - | *MOMCPU :                         C - |
*MOMCPUNAME :                 SC/MP - | *NESTMAX :                      100 - |
*PACKING :                        0 - | *PADDING :                        1 - |
 PARPOSN :                      C1C - |  PRINT :                         9E C |
 PRINTADDRESSDATA :             5A1 C |  PRINTCHARACTER :               534 C |
 PRINTHEXBYTE :                 501 C |  PUTTAPE_COMMAND :              351 C |
*RELAXED :                        0 - |  SCREENCURSOR :                 C80 - |
 SCREENMIRROR :                 C00 - |  SCREEN__END :                  15E C |
 TAPEDELAY :                      4 - | *TIME :                    15:58:10 - |
*TRUE :                           1 - | *UPDATECURRENTADDRESS :         664 C |
 VARBASE :                      C18 - | *VERSION :                     142F - |
 _KBDWAITKEY :                  1FE C |  _KBDWAITRELEASE :              1F8 C |
 _PADLOOP :                     5C1 C |  _PADPRINT :                    5CE C |
 _PUTTAPEBIT :                  381 C |  _PUTTAPEBYTE :                 36C C |
 _PUTTAPELEADER :               366 C |  __ASMCONTINUE :                2EF C |
 __ASMEXIT :                    327 C |  __ASMNOPARAMETER :             2E7 C |
 __ASSEMBLER :                  2B8 C |  __BOOTMONITOR :                168 C |
 __CMDMAINLOOP1 :               23C C |  __CMDMAINLOOP2 :               33D C |
 __CMDMAINLOOP3 :               34F C |  __CMDMAINLOOP4 :               39E C |
 __CMDMAINLOOP5 :               3C8 C |  __CMDMAINLOOP6 :               410 C |
 __CMDMAINLOOP7 :               47C C |  __CMDPARAMETERFAIL :           335 C |
 __CMDPARAMETERFAIL1 :          3A0 C |  __COMMANDERROR :               2AE C |
 __COMMANDLIST :                747 C |  __COMMANDLISTEND :             7EC C |
 __COMMANDTABLE :               7EE C |  __DASSFINDOPCODE :             463 C |
 __DASSFOUNDOPCODE :            47E C |  __DASSLOOP :                   43A C |
 __DASSLOOP2 :                  47A C |  __DASSNEXT :                   4D8 C |
 __DASSNEXTOPCODE :             476 C |  __DASSNOOPERAND :              459 C |
 __DASSNOTAUTOINDEXED :         4F5 C |  __DASSNOTIMMEDIATE :           48A C |
 __DASSPRINTMNEMONIC :          49F C |  __DASSPRINTMODIFIER :          4E9 C |
 __DASSPRINTOPERAND :           4CA C |  __DASSSHIFTENCODE :            4AF C |
 __DASSSKIPSPACE :              4AB C |  __DCLOOP :                     3EE C |
 __EX5SHIFT :                   256 C |  __EXTRACTEND :                 26C C |
 __FINDCOMMANDLOOP :            277 C |  __GCNOTLOWER [GETCHAR] :        2F C |
 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 32 - 1/17/2016 15:58:10


 __GCWAITKEY [GETCHAR] :         15 C |  __GCWAITRELEASE [GETCHAR] :     1D C |
 __GETTAPEBITS :                3B8 C |  __GETTAPEWAIT :                3A8 C |
 __GPAADJUSTMODIFIER :          651 C |  __GPAATMODIFIER :              64F C |
 __GPAEXIT :                    663 C |  __GPAEXITFAIL :                662 C |
 __GPAFOUNDHEX :                60A C |  __GPANEXTCHARACTER :           5F5 C |
 __GPAPOINTERMODIFIER :         641 C |  __GPASHIFT :                   614 C |
 __GPASKIP :                    5E3 C |  __GSBACKSPACE [GETSTRING] :     91 C |
 __GSCONTROLKEY [GETSTRING] :    74 C |  __GSLOOP [GETSTRING] :          44 C |
 __KBDBACKSPACE :               230 C |  __KBDEXIT :                    23E C |
 __KBDNOTLOWER :                224 C |  __PCBACKSPACE :                589 C |
 __PCBLANKNEWLINE :             565 C |  __PCBLANKNEWLINELOOP :         569 C |
 __PCEXIT :                     571 C |  __PCNEWLINE :                  595 C |
 __PHBNOSPACE :                 513 C |  __PRCLEARFROMMOVETO [PRINT] :  13E C |
 __PRCLEARLOOP [PRINT] :        140 C |  __PRCLEARSCREEN [PRINT] :      13C C |
 __PRCOPY [PRINT] :             14A C |  __PREXIT [PRINT] :             101 C |
 __PREXITNOCHECK [PRINT] :      105 C |  __PRINT2 :                      34 C |
 __PRISCONTROLCHAR [PRINT] :    113 C |  __PRISRETURN [PRINT] :         133 C |
 __PRNOTASCII [PRINT] :          DB C |  __PRPRINTCHARACTERA [PRINT] :   BF C |
 __PRPRINTSTRING [PRINT] :       AD C |  __PRSCROLLLOOP [PRINT] :        F3 C |
 __PRUPDATECURSOR [PRINT] :      E4 C |  __SCREEN_OVER1 :                 9 C |
 __UCAEXIT :                    673 C |

    155 symbols
     31 unused symbols

 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 33 - 1/17/2016 15:58:10


  defined macros:
  ---------------

LPI                                   | PULLA                                
PULLE                                 | PULLP                                
PUSHA                                 | PUSHE                                
PUSHP                                 |

      7 macros

 AS V1.42 Beta [Bld 102] - source file monitor.asm - page 34 - 1/17/2016 15:58:10


  codepages:
  ----------

STANDARD (0 changed characters)


0.01 seconds assembly time

   1692 lines source file
   1736 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
